Path: D:\Modible\Software\pocketbase-sveltekit-starter\.dockerignore
Contents:
# flyctl launch added from .gitignore
**\.cache
**\.local
**\.npm
**\.env
**\.ash_history
docker-compose.override.yml

# flyctl launch added from pb\.gitignore
pb\.cache
pb\pocketbase
pb\pocketbase*.zip
pb\pb_data
pb\tmp
# pb\pb_public

# flyctl launch added from sk\.gitignore
sk\**\.DS_Store
sk\**\node_modules
sk\playwright-report
# sk\build
sk\.svelte-kit
sk\package
sk\**\.env
sk\**\.env.*
!sk\**\.env.example

# flyctl launch added from sk\node_modules\.pnpm\digest-fetch@1.3.0\node_modules\digest-fetch\.gitignore
!sk\node_modules\.pnpm\digest-fetch@1.3.0\node_modules\digest-fetch\**\.gitignore
sk\node_modules\.pnpm\digest-fetch@1.3.0\node_modules\digest-fetch\**\node_modules
sk\node_modules\.pnpm\digest-fetch@1.3.0\node_modules\digest-fetch\**\packing


# flyctl launch added from sk\node_modules\.pnpm\minipass-sized@1.0.3\node_modules\minipass-sized\.gitignore
# ignore most things, include some others
sk\node_modules\.pnpm\minipass-sized@1.0.3\node_modules\minipass-sized\*
sk\node_modules\.pnpm\minipass-sized@1.0.3\node_modules\minipass-sized\.*

!sk\node_modules\.pnpm\minipass-sized@1.0.3\node_modules\minipass-sized\**\bin
!sk\node_modules\.pnpm\minipass-sized@1.0.3\node_modules\minipass-sized\**\lib
!sk\node_modules\.pnpm\minipass-sized@1.0.3\node_modules\minipass-sized\**\docs
!sk\node_modules\.pnpm\minipass-sized@1.0.3\node_modules\minipass-sized\**\package.json
!sk\node_modules\.pnpm\minipass-sized@1.0.3\node_modules\minipass-sized\**\package-lock.json
!sk\node_modules\.pnpm\minipass-sized@1.0.3\node_modules\minipass-sized\**\README.md
!sk\node_modules\.pnpm\minipass-sized@1.0.3\node_modules\minipass-sized\**\CONTRIBUTING.md
!sk\node_modules\.pnpm\minipass-sized@1.0.3\node_modules\minipass-sized\**\LICENSE
!sk\node_modules\.pnpm\minipass-sized@1.0.3\node_modules\minipass-sized\**\CHANGELOG.md
!sk\node_modules\.pnpm\minipass-sized@1.0.3\node_modules\minipass-sized\**\example
!sk\node_modules\.pnpm\minipass-sized@1.0.3\node_modules\minipass-sized\**\scripts
!sk\node_modules\.pnpm\minipass-sized@1.0.3\node_modules\minipass-sized\**\tap-snapshots
!sk\node_modules\.pnpm\minipass-sized@1.0.3\node_modules\minipass-sized\**\test
!sk\node_modules\.pnpm\minipass-sized@1.0.3\node_modules\minipass-sized\**\.travis.yml
!sk\node_modules\.pnpm\minipass-sized@1.0.3\node_modules\minipass-sized\**\.gitignore
!sk\node_modules\.pnpm\minipass-sized@1.0.3\node_modules\minipass-sized\**\.gitattributes
!sk\node_modules\.pnpm\minipass-sized@1.0.3\node_modules\minipass-sized\**\coverage-map.js
!sk\node_modules\.pnpm\minipass-sized@1.0.3\node_modules\minipass-sized\**\index.js

# flyctl launch added from sk\node_modules\.pnpm\tailwindcss@3.4.1\node_modules\tailwindcss\stubs\.gitignore
!sk\node_modules\.pnpm\tailwindcss@3.4.1\node_modules\tailwindcss\stubs\**\*
fly.toml


Path: D:\Modible\Software\pocketbase-sveltekit-starter\click on a bullet point and generat.txt
Contents:
click on a bullet point and generate a new article
generate a tree based on the article tags and titles

-------
Remember

One Sentence.
->
Interpret users intent
-> respond with 3 different interpretations of the users entry
User selects an option
Blog is generated based on user selection.

-------
Create

1) User can view a blog a click bullet points to generate new articles
2) User can enter a new statement
->
Interpret users intent
-> respond with 3 different interpretations of the users entry
User selects an option
Blog is generated based on user selection.
3) User can ask the AI to generate 3 new concepts/ideas based on the article
-> User can choose which one the generate a new article

User can enter notes about the blog

-------
Inspire

User can view a tree of the blogs.
User can select tags to filter blogs
User can add multiple blogs, and generate a new blog based on them

This will have a left pane and a main window

The left pane will have the tree

you can search the tags in a search menu and it will change the main view to the returned blogs

----------------

Project Overview: AI Journal Webapp
Menu System and Navigation:
A fixed, globally accessible menu provides seamless navigation across the app, featuring links to all main pages: Home (Create Page), Remember, Inspire, Explore, Reflect, and any other utility pages like Settings or Help.
The menu integrates user-centric features like quick access to recent documents, a search bar for content within the app, and user profile settings.
Pages and Functionalities:
Home (Create Page)

Functionality: Central hub for content creation, featuring a minimalist design with a versatile input box for text, links, or questions. The system dynamically responds based on the type of input.
Data Interactions: Inputs are processed to generate content, parse links, or provide answers. User-generated content is saved and can be linked or referenced in other areas of the app.
Prototype Code: Function to process user input and determine action.
python
Copy code
def process_input(user_input):
    # Pseudocode to categorize input type
    if is_link(user_input):
        return parse_link(user_input)
    elif is_question(user_input):
        return generate_answer(user_input)
    else:
        return generate_content(user_input)
Remember Page

Functionality: Allows users to input a thought and receive multiple interpretations or expansions. Users select one to develop into a full article.
Data Interactions: Inputs and selections are stored for user history and can influence future content recommendations or interpretations.
Prototype Code: Function to interpret user input.
python
Copy code
def interpret_thought(user_thought):
    # Generate interpretations (simplified)
    interpretations = generate_interpretations(user_thought)
    return interpretations
Inspire Page

Functionality: Visual and interactive exploration of blog connections and content synthesis based on selected blogs or tags.
Data Interactions: Uses tag and content metadata to organize and display connections. User selections for synthesis are processed to create new, combined content.
Prototype Code: Function to synthesize content from selections.
python
Copy code
def synthesize_content(selected_blogs):
    # Combine content from selected blogs
    combined_content = combine(selected_blogs)
    return combined_content
Explore Page

Functionality: Discovery of AI-curated content and random content suggestions. Includes personalized recommendations based on user activity.
Data Interactions: Tracks user interactions to refine recommendations. External data (e.g., trending topics) may be incorporated for curation.
Prototype Code: Function for personalized recommendations.
python
Copy code
def get_recommendations(user_profile):
    # Fetch recommendations based on user profile
    recommendations = fetch_curated_content(user_profile)
    return recommendations
Reflect Page

Functionality: Private space for journaling and personal reflection with prompts based on user activity or significant dates. Offers growth tracking and insights.
Data Interactions: Interacts with user-generated content and activity logs to provide personalized prompts and track personal growth metrics.
Prototype Code: Function to generate reflection prompts.
python
Copy code
def generate_reflection_prompt(user_activity):
    # Generate prompts based on user activity
    prompt = create_prompt(user_activity)
    return prompt
Interconnections and Data Flow:
User Profile and Activity Tracking: Central to personalizing experiences across Explore, Reflect, and personalized content recommendations. User data, including preferences, content interactions, and history, is stored securely and used to tailor app interactions.
Content Creation and Sharing: Content generated or curated by the user in the Create and Remember pages can be shared, tagged, and integrated into the Inspire and Explore pages for broader community engagement.
External Data Integration: For the Explore page and content parsing features (e.g., summarizing shared links), external APIs or scraping techniques may be employed, adhering to privacy and copyright laws.
Implementation Considerations:
Security and Privacy: Ensure user data is handled securely, with clear privacy policies and compliance with regulations (e.g., GDPR).
Scalability: Design backend systems to handle increasing amounts of user data and content efficiently.
User Experience: Focus on intuitive design and seamless navigation across pages, ensuring responsiveness and accessibility.

Path: D:\Modible\Software\pocketbase-sveltekit-starter\Dockerfile
Contents:
FROM golang:1.22-alpine AS builder
WORKDIR /build
COPY pb/go.mod pb/go.sum ./
RUN go mod download
COPY pb/main.go ./
COPY pb/hooks ./hooks
RUN apk --no-cache add upx make git gcc libtool musl-dev ca-certificates dumb-init \
  && go mod tidy \
  && CGO_ENABLED=0 go build \
  && upx pocketbase

FROM alpine
WORKDIR /app/pb
COPY --from=builder /build/pocketbase /app/pb/pocketbase
COPY pb/pb_migrations ./pb_migrations
COPY ./sk/build ./pb_public
COPY pb/data/email_templates ./data/email_templates

ENTRYPOINT ["/app/pb/pocketbase", "serve", "--http", "0.0.0.0:8090", "--publicDir", "/app/pb/pb_public"]

Path: D:\Modible\Software\pocketbase-sveltekit-starter\fly.toml
Contents:
# fly.toml app configuration file generated for pocketbase-sveltekit-starter-restless-river-3259 on 2024-03-24T11:59:12-05:00
#
# See https://fly.io/docs/reference/configuration/ for information about how to use this file.
#

app = 'pocketbase-sveltekit-starter-restless-river-3259'
primary_region = 'atl'

[build]
  dockerfile = 'Dockerfile'

[http_service]
  internal_port = 8090
  force_https = true
  auto_stop_machines = false
  auto_start_machines = false
  min_machines_running = 1
  processes = ['app']

[[vm]]
  memory = '1gb'
  cpu_kind = 'shared'
  cpus = 1


Path: D:\Modible\Software\pocketbase-sveltekit-starter\LICENSE.md
Contents:
The MIT License (MIT)
Copyright (c) 2022 - present, Jitesh Doshi

Permission is hereby granted, free of charge, to any person obtaining a copy of this software
and associated documentation files (the "Software"), to deal in the Software without restriction,
including without limitation the rights to use, copy, modify, merge, publish, distribute,
sublicense, and/or sell copies of the Software, and to permit persons to whom the Software
is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or
substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING
BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.


Path: D:\Modible\Software\pocketbase-sveltekit-starter\Procfile
Contents:
web: ./pb/pocketbase serve --http 0.0.0.0:$PORT

Path: D:\Modible\Software\pocketbase-sveltekit-starter\README.md
Contents:
# PocketBase / SvelteKit Starter App

Use this app as a starting point for your own _customized_
[PocketBase](https://github.com/pocketbase/pocketbase) backend
with [SvelteKit](https://kit.svelte.dev) frontend.
This is a high-performance frontend+backend combination since frontend
is static and backend is a single compiled Golang binary (JAMstack baby!).

- SvelteKit frontend is fully static, client-side only so that here is no need
  for NodeJS at runtime. It is generated using [`adapter-static`](https://github.com/sveltejs/kit/tree/master/packages/adapter-static) and `ssr` is OFF.
- PocketBase provides complete (and _fast_) backend including:
  - databse (SQLite)
  - CRUD API for database
  - realtime subscriptions for LIVE data (server push to browser)
  - Authentication and Authorization (email + social login/oauth2)
  - file storage (local filesystem or S3)
  - hooks and API endpoints implemented in JavaScript ([goja](https://github.com/dop251/goja))
- PocketBase can be downloaded as binary. But if you want to extend it with
  custom Golang code then code is included to compile it locally with
  extensions such as custom endpoints (e.g. `/api/hello`) and database event
  hooks (e.g. executing Go handler functions when a database row is created)
- It is now also possible to [extend the backend with JavaScript](https://pocketbase.io/docs/js-overview/).
  See the example [main.pb.ts](./pb/pb_hooks/main.pb.ts).
- A full live development setup is included
  - Hot Module Reloading (HMR) of your frontend app when you edit Svelte code (including proxying requests to the PocketBase backend via `vite`)
  - Hot reloading (restarting) of the PocketBase server using `modd` when you edit Go code
  - Hot reloading (restarting) of the PocketBase server when JS code is changed in `./pb/pb_hooks`

To understand the backend, see [./pb/README.md](./pb/README.md) ("pb" == PocketBase)
To understand the frontend, see [./sk/README.md](./sk/README.md) ("sk" == SvelteKit)

Read those README files before proceeding.

# Setup

Follow these steps CAREFULLY, or else it won't work. Also read the README files referred above before proceeding.

1. If using Docker then copy `.env.example` to `.env` and then edit it to match your environment. And then just run `docker compose up -d`. Without Docker, see below ...
2. Setup the backend in accordance with [./pb/README.md](./pb/README.md)
3. Setup the frontend in accordance with [./sk/README.md](./sk/README.md)

# Developing

After you've done the setup in the above two README files, run
the backend and the frontend in dev mode (from `sk` directory).

```bash
# start the backend
npm run dev:backend
# and then start the frontend ...
npm run dev
```

Now visit http://localhost:5173 (sk) or http://localhost:8090 (pb)

Now making changes in the Svelte code (frontend) or Go code (backend) will show
results (almost) immediately.

# Usage

To use the app as a user / tester ...

- visit the frontend URL (e.g. http://localhost:5173)
- Navigate around. The Home page is not very interesting.
- The `hello` page shows and example of frontend calling a custom backend API implemented in Go.
- The `posts` page shows all existing posts. If that page is empty, then you might want to create some posts. You must be logged in to be able to create posts.
- Into the `Login` form, you can enter an existing username/password, or check the `register` checkbox to create a new account (it registers the user and log in immediately).

The above are just some sample features. Now go ahead and implement all kinds of new features.

- Create new collections.
- Create new pages that manipulate the above collections.

# Building

See the build process details in the README files for backend and frontend.

# Configurable Hooks

Please read about the "hooks" system in [./pb/README.md](./pb/README.md)
It is a very easy and powerful way to extend your application with minimal
configuration and perhaps no code.

# Feedback

Please provide feedback by
[opening an issue](https://github.com/spinspire/pocketbase-sveltekit-starter/issues/new)
or
[starting a discussion](https://github.com/spinspire/pocketbase-sveltekit-starter/discussions).


Path: D:\Modible\Software\pocketbase-sveltekit-starter\runit.bat
Contents:
@echo off
setlocal

REM Navigate to the PocketBase directory and build the project
cd pb
call go build
start cmd /k "pocketbase serve"

REM Navigate to the SvelteKit directory and start the dev server
cd ../sk
start cmd /k "pnpm run dev"

endlocal


Path: D:\Modible\Software\pocketbase-sveltekit-starter\textGen.py
Contents:

import os
import fnmatch

def is_excluded(file_path, exclude_patterns):
    for pattern in exclude_patterns:
        if fnmatch.fnmatch(file_path, pattern):
            print(f"Excluded by pattern {pattern}: {file_path}")
            return True
    return False

def is_binary(file_path):
    try:
        with open(file_path, 'rb') as file:
            if b'\0' in file.read(1024):
                print(f"Identified as binary: {file_path}")
                return True
    except Exception as e:
        print(f"Error checking if binary {file_path}: {e}")
    return False

def generate_tree_view(start_dir, tree, prefix=''):
    tree_view = ''
    for index, (path, sub_tree) in enumerate(tree.items()):
        connector = "└── " if index == len(tree) - 1 else "├── "
        tree_view += f"{prefix}{connector}{os.path.basename(path)}\n"
        if isinstance(sub_tree, dict):  # If the item is a directory
            extension = "    " if index == len(tree) - 1 else "│   "
            tree_view += generate_tree_view(path, sub_tree, prefix=prefix + extension)
    return tree_view

def parse_directory_to_file(output_file_name):
    start_dir = os.getcwd()
    output_file_path = os.path.join(start_dir, output_file_name)

    exclude_patterns = [
        '*/.cache*', '*/.local*', '*/.npm*', '*/.env*', '*/.ash_history*',
        '*/docker-compose.override.yml*', '*/pocketbase.exe', '*/pocketbase*.zip', '*/pb_data*', 
        '*/tmp*', '*/.DS_Store*', '*/node_modules*', '*/playwright-report*', '*/build*', 
        '*/.svelte-kit*', '*/package*', '*/.env*', '*/.env.*', '!*/.env.example*', '*/.txt',
        '*.pyc', '*.log', '*~', '*.tmp', '*.bak', '*.swp', '*.mod', '*/oldMigrations*',
        '*.dll', '*.exe', '*.png', '*.jpg', '*.jpeg', '*.gif', '*/.git*', '*/pb_migrations*',
        '*.yml', '*.yaml', '.gitignore', '*.sum', 'directory_contents_filtered_debug.txt','textGen.*' # Additional patterns
    ]

    tree_structure = {}
    with open(output_file_path, 'w', encoding='utf-8') as output_file:
        print(f"Starting directory traversal from {start_dir}")
        for root, dirs, files in os.walk(start_dir):
            print(f"Processing directory: {root}")
            dirs[:] = [d for d in dirs if not is_excluded(os.path.join(root, d), exclude_patterns)]
            files = [f for f in files if not is_excluded(os.path.join(root, f), exclude_patterns) and os.path.join(root, f) != output_file_path]
            
            # Update tree_structure
            path_parts = root.replace(start_dir, '').strip(os.sep).split(os.sep)
            current_level = tree_structure
            for part in path_parts:
                current_level = current_level.setdefault(part, {})
            for file in files:
                current_level[file] = {}

            for file in files:
                file_path = os.path.join(root, file)
                if is_binary(file_path):
                    continue
                
                try:
                    with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
                        contents = f.read()
                    output_file.write(f"Path: {file_path}\nContents:\n{contents}\n\n")
                    print(f"Included: {file_path}")
                except Exception as e:
                    print(f"Error processing file {file_path}: {e}")
        
        # Generate and write the tree view
        tree_view = generate_tree_view(start_dir, tree_structure)
        output_file.write(f"Project Tree View:\n{tree_view}")

# Example usage
output_file_name = "directory_contents_filtered_debug.txt"
parse_directory_to_file(output_file_name)


Path: D:\Modible\Software\pocketbase-sveltekit-starter\.vscode\settings.json
Contents:
{
    "zenMode.showTabs": "multiple"
}

Path: D:\Modible\Software\pocketbase-sveltekit-starter\pb\entrypoint.sh
Contents:
#!/bin/sh
set -e # exit on any non-zero status (error)

# this entrypoint script checks that all required setup is done
# if not done, does it
# and then proceeds to execute the main "command" for this container

# build if needed
go mod tidy
go build

if [ ! -x "$(which modd)" ]; then
  echo "go install modd"
  go install github.com/cortesi/modd/cmd/modd@latest
fi

exec "$@"

Path: D:\Modible\Software\pocketbase-sveltekit-starter\pb\example-hook-script.sh
Contents:
#!/usr/bin/env bash

# This example script, along with hooks.go, shows how to trigger a command
# when a record changes in PocketBase and how to feed the changed record to this
# script.

params=$1 # `action_params` field passed from the "hooks" table
echo "PARAMS=$params"

# The body of the record (as JSON) is fed to this script as stdin.
# The following just reformats it and pretty-prints it.
cat | jq -C

Path: D:\Modible\Software\pocketbase-sveltekit-starter\pb\main.go
Contents:
package main

import (
	"bytes"
	"encoding/base64"
	"encoding/json"
	"fmt"
	//"io"
	"context"
	"io/ioutil"
	"log"
	"net/http"
	"os"
	"path/filepath"
	"strings"
	"time"

	//"pocketbase/auditlog"
	hooks "pocketbase/hooks"

	"github.com/joho/godotenv"

	"github.com/labstack/echo/v5"
	"github.com/pocketbase/pocketbase"
	"github.com/pocketbase/pocketbase/apis"
	"github.com/pocketbase/pocketbase/core"
	"github.com/pocketbase/pocketbase/plugins/jsvm"
	"github.com/pocketbase/pocketbase/plugins/migratecmd"

	"errors"
	"github.com/liushuangls/go-anthropic"
	//"github.com/pocketbase/pocketbase/forms"
	//"github.com/pocketbase/pocketbase/models"
	// Create a new form for the record upsert
	//"github.com/pocketbase/filesystem"
)

type TextToImage struct {
	Base64       string `json:"base64"`
	Seed         uint32 `json:"seed"`
	FinishReason string `json:"finishReason"`
}

type TextToImageResponse struct {
	Images []TextToImage `json:"artifacts"` // Ensure the JSON tag matches the key in the response
}

// DreamStudioResponse is a placeholder for the actual response structure from DreamStudio.
type DreamStudioResponse struct {
	Images []struct {
		Base64 string `json:"base64"`
	} `json:"images"`
}

// ImageUploadResponse is the structure of the response returned after a successful image upload.
type ImageUploadResponse struct {
	ID string `json:"id"` // or URL if you prefer to return the image URL
}

const (
	PostsCollection         = "posts"
	ImagesCollection        = "images"
	DefaultAPIHost          = "https://api.stability.ai"
	StableDiffusionEngineID = "stable-diffusion-v1-6"
)

type requestBodyStruct struct {
	Prompt string `json:"prompt"`
	Slug   string `json:"slug"`
}

func getEnv(key, fallback string) string {
	if value, exists := os.LookupEnv(key); exists {
		return value
	}
	return fallback
}

// func imagesHandler(app *pocketbase.PocketBase, ) echo.HandlerFunc {
// 	return func(c echo.Context) error {
// 		// Parse the multipart form
// 		if err := c.Request().ParseMultipartForm(32 << 20); err != nil {
// 			return c.JSON(http.StatusBadRequest, map[string]string{"error": "Failed to parse multipart form"})
// 		}

// 		// Retrieve the file from the form data
// 		file, _, err := c.Request().FormFile("file")
// 		if err != nil {
// 			return c.JSON(http.StatusBadRequest, map[string]string{"error": "Failed to get the file from the form"})
// 		}
// 		defer file.Close()

// 		// Find the images collection
// 		collection, err := app.Dao().FindCollectionByNameOrId(ImagesCollection)
// 		if err != nil {
// 			return c.JSON(http.StatusInternalServerError, map[string]string{"error": "Failed to find images collection"})
// 		}

// 		// Create a new record for the images collection
// 		record := models.NewRecord(collection)

// 		form := forms.NewRecordUpsert(app, record)

// 		// Manually upload the file using the local file path
// 		fileObject, err := filesystem.NewFileFromPath(localFilePath)

// 		if err != nil {
// 			return c.JSON(http.StatusInternalServerError, map[string]string{"error": "Failed to create file object from path"})
// 		}

// 		// Add the file to the form
// 		form.AddFiles("file", fileObject) // Replace "file" with the actual field name in the images collection

// 		// Validate and submit the form
// 		if err := form.Submit(); err != nil {
// 			return c.JSON(http.StatusInternalServerError, map[string]string{"error": "Failed to save image record"})
// 		}

// 		// Return the response with the ID of the uploaded image
// 		return c.JSON(http.StatusOK, ImageUploadResponse{ID: record.Id})
// 	}
// }

func defaultPublicDir() string {
	if strings.HasPrefix(os.Args[0], os.TempDir()) {
		// most likely ran with go run
		return "./pb_public/"
	}

	return filepath.Join(os.Args[0], "../pb_public/")
}

// use godot package to load/read the .env file and
// return the value of the key
func goDotEnvVariable(key string) string {

	// load .env file
	err := godotenv.Load(".env")

	if err != nil {
		log.Fatalf("Error loading .env file")
	}

	return os.Getenv(key)
}

func servicesHandler(c echo.Context) error {
	services := []map[string]interface{}{
		{
			"name":   "Anthropic",
			"models": []string{"claude-instant-v1", "claude-instant-v1-100k"},
		},
		{
			"name":   "OpenAI",
			"models": []string{"gpt-3.5-turbo", "gpt-4"},
		},
	}

	return c.JSON(http.StatusOK, services)
}

func claudeHandler(c echo.Context) error {
	var requestBody struct {
		Text  string `json:"text"`
		Model string `json:"model"`
	}

	if err := c.Bind(&requestBody); err != nil {
		return c.JSON(http.StatusBadRequest, map[string]string{"error": "Invalid request body"})
	}

	client := anthropic.NewClient(goDotEnvVariable("ANTHROPIC_API_KEY"))

	resp, err := client.CreateMessages(context.Background(), anthropic.MessagesRequest{
		Model: requestBody.Model,
		Messages: []anthropic.Message{
			anthropic.NewUserTextMessage(requestBody.Text),
		},
		MaxTokens: 1000,
	})
	if err != nil {
		var e *anthropic.APIError
		if errors.As(err, &e) {
			fmt.Printf("Messages error, type: %s, message: %s", e.Type, e.Message)
		} else {
			fmt.Printf("Messages error: %v\n", err)
		}
		return err
	}

	fmt.Println(resp.Content[0].Text)

	return c.JSON(http.StatusOK, map[string]interface{}{"result": resp.Content[0].Text})
}

func chatGptHandler(c echo.Context) error {
	var requestBody struct {
		Text  string `json:"text"`
		Model string `json:"model"`
	}

	log.Println("Received request to /api/openai")

	if err := c.Bind(&requestBody); err != nil {
		log.Printf("Error in chatGptHandler: %v", err)
		return c.JSON(http.StatusBadRequest, map[string]string{"error": "Invalid request"})
	}

	chatGPTAPIKey := goDotEnvVariable("CHATGPT_API_KEY")

	result, err := hooks.DoChatGPT(chatGPTAPIKey, requestBody.Text, requestBody.Model)
	if err != nil {
		log.Printf("Error in chatGptHandler: %v", err)
		return c.JSON(http.StatusInternalServerError, map[string]string{"error": "Failed to generate text from ChatGPT"})
	}

	return c.JSON(http.StatusOK, map[string]interface{}{"result": result})
}

func dalleImageHandler(c echo.Context) error {
	var requestBody struct {
		Prompt string `json:"prompt"`
	}

	if err := c.Bind(&requestBody); err != nil {
		return c.JSON(http.StatusBadRequest, map[string]string{"error": "Invalid request"})
	}

	dalleAPIKey := goDotEnvVariable("CHATGPT_API_KEY") // Ensure this is correctly named. Adjust according to your actual environment variable retrieval function
	prompt := requestBody.Prompt
	model := "dall-e-2" // Make sure to use the correct model name
	size := "512x512"   // Adjust based on what sizes your model supports

	b64Data, err := hooks.DoDalle3(dalleAPIKey, prompt, model, size)
	if err != nil {
		log.Printf("Error generating image: %v", err)
		return c.JSON(http.StatusInternalServerError, map[string]string{"error": "Failed to generate image"})
	}

	// Decode base64 string to []byte
	data, err := base64.StdEncoding.DecodeString(b64Data)
	if err != nil {
		log.Printf("Error decoding base64 data: %v", err)
		return c.JSON(http.StatusInternalServerError, map[string]string{"error": "Failed to decode image data"})
	}

	// Create a unique file name
	fileName := fmt.Sprintf("dalle_image_%v.png", time.Now().Unix())
	filePath := filepath.Join("./pb_public/", fileName) // Adjust the path as necessary

	// Write data to file
	err = os.WriteFile(filePath, data, 0644)
	if err != nil {
		log.Printf("Error writing image to file: %v", err)
		return c.JSON(http.StatusInternalServerError, map[string]string{"error": "Failed to save image file"})
	}

	// Construct the full URL to return
	url := fmt.Sprintf("http://localhost:8090/%s", fileName)

	// Return the full URL to the frontend
	return c.JSON(http.StatusOK, map[string]interface{}{"url": url})
}

func dreamStudioHandler(c echo.Context) error {
	var requestBody struct {
		Prompt string `json:"prompt"`
	}
	if err := c.Bind(&requestBody); err != nil {
		return c.JSON(http.StatusBadRequest, map[string]string{"error": "Invalid request body"})
	}

	requestData := map[string]interface{}{
		"prompt": requestBody.Prompt,
		// Add additional required fields by DreamStudio API here
	}

	requestBodyJson, _ := json.Marshal(requestData)
	apiUrl := "https://api.dreamstudio.com/generate" // Placeholder URL

	req, _ := http.NewRequest("POST", apiUrl, bytes.NewBuffer(requestBodyJson))
	req.Header.Set("Authorization", "Bearer "+os.Getenv("DREAMSTUDIO_API_KEY"))
	req.Header.Set("Content-Type", "application/json")

	client := &http.Client{}
	resp, err := client.Do(req)
	if err != nil {
		log.Printf("Failed to request DreamStudio: %v\n", err)
		return c.JSON(http.StatusInternalServerError, map[string]string{"error": "Failed to generate image"})
	}
	defer resp.Body.Close()

	var dsResponse DreamStudioResponse

	if err := json.NewDecoder(resp.Body).Decode(&dsResponse); err != nil {
		log.Printf("Failed to decode DreamStudio response: %v\n", err)
		return c.JSON(http.StatusInternalServerError, map[string]string{"error": "Failed to decode DreamStudio response"})
	}

	if len(dsResponse.Images) == 0 {
		return c.JSON(http.StatusInternalServerError, map[string]string{"error": "No images returned from DreamStudio"})
	}

	// Assuming `firstImageBase64` is your base64 encoded image string.
	decodedImage, err := base64.StdEncoding.DecodeString(dsResponse.Images[0].Base64)
	if err != nil {
		log.Printf("Error decoding image: %v\n", err)
		return c.JSON(http.StatusInternalServerError, map[string]string{"error": "Failed to decode image data"})
	}

	// Save decoded image as a temporary file
	// Ensure the ./pb_public/temp/ directory exists or adjust the path according to your setup
	tempFilePath := filepath.Join("./pb_public/temp/", fmt.Sprintf("temp_image_%v.png", time.Now().UnixNano()))
	if err := ioutil.WriteFile(tempFilePath, decodedImage, 0644); err != nil {
		log.Printf("Error saving temp image file: %v\n", err)
		return c.JSON(http.StatusInternalServerError, map[string]string{"error": "Failed to save temp image file"})
	}

	// Construct a URL to access the temporary image

	tempFileURL := fmt.Sprintf("http://localhost:8090/%s", strings.TrimPrefix(tempFilePath, "./pb_public/"))

	return c.JSON(http.StatusOK, map[string]interface{}{"imageUrl": tempFileURL})
}

/* fileName := fmt.Sprintf("dreamstudio_image_%v.png", time.Now().Unix())
filePath := filepath.Join("./pb_public/", fileName)

err = os.WriteFile(filePath, imageData, 0644)
if err != nil {
	log.Printf("Error writing image to file: %v\n", err)
	return c.JSON(http.StatusInternalServerError, map[string]string{"error": "Failed to save image file"})
}

url := fmt.Sprintf("http://localhost:8090/%s", fileName)

log.Println("Returning image URL to the client")
return c.JSON(http.StatusOK, map[string]interface{}{"url": url}) */

func main() {
	app := pocketbase.New()

	var publicDirFlag string = "./pb_public" // Ensure this points to the correct directory

	// add "--publicDir" option flag
	app.RootCmd.PersistentFlags().StringVar(
		&publicDirFlag,
		"publicDir",
		defaultPublicDir(),
		"the directory to serve static files",
	)

	// load js files to allow loading external JavaScript migrations
	jsvm.MustRegister(app, jsvm.Config{
		HooksWatch: true, // make this false for production
	})

	// register the `migrate` command
	migratecmd.MustRegister(app, app.RootCmd, migratecmd.Config{
		TemplateLang: migratecmd.TemplateLangJS, // or migratecmd.TemplateLangGo (default)
		Automigrate:  true,
	})

	// call this only if you want to auditlog tables named in AUDITLOG env var
	//auditlog.Register(app)

	// call this only if you want to use the configurable "hooks" functionality
	hooks.PocketBaseInit(app)

	app.OnBeforeServe().Add(func(e *core.ServeEvent) error {

		// Register all specific routes before the wildcard static file handler
		//e.Router.POST("/api/chatgpt", chatGptHandler)
		e.Router.POST("/api/dalle", dalleImageHandler)
		//e.Router.POST("/api/claude", claudeHandler)
		// Register the /api/images route with the imagesHandler
		//e.Router.POST("/api/images", imagesHandler(app))
		e.Router.POST("/api/dreamstudio", dreamStudioHandler)

		e.Router.GET("/api/services", servicesHandler)
		e.Router.POST("/api/anthropic", claudeHandler)
		e.Router.POST("/api/openai", chatGptHandler)
		// Now register the static file handler
		e.Router.GET("/*", apis.StaticDirectoryHandler(os.DirFS(publicDirFlag), true))

		log.Println("Serving static files from", publicDirFlag)

		/* e.Router.AddRoute(echo.Route{
		Method: http.MethodGet,
		Path:   "/api/hello",
		Handler: func(c echo.Context) error {
			obj := map[string]interface{}{"message": "Hello world!"}
			return c.JSON(http.StatusOK, obj)
		}, */
		// Middlewares: []echo.MiddlewareFunc{
		// 	apis.RequireAdminOrUserAuth(),
		// },
		//})

		return nil
	})

	if err := app.Start(); err != nil {
		log.Fatal(err)
	}
}


Path: D:\Modible\Software\pocketbase-sveltekit-starter\pb\modd.conf
Contents:
# Run go test on ALL modules on startup, and subsequently only on modules
# containing changes.
**/*.go {
    prep: go build
    # prep: go test @dirmods
    daemon +sigterm: ./pocketbase serve --debug --http 0.0.0.0:8090 --publicDir ../sk/build
}


Path: D:\Modible\Software\pocketbase-sveltekit-starter\pb\README.md
Contents:
# Backend with PocketBase

There are two flavors of the backend:

1. Standard release downloaded from https://github.com/pocketbase/pocketbase/releases. It even allows [extending with JavaScript](https://pocketbase.io/docs/js-overview/). This one is a good start, but if you want full control see next.
2. Custom compiled (`go build`), possibly with my customizations and perhaps yours too.

Out of the box, the project assumes #2 (custom compiled with my customizations).

## standard (official) release of pocketbase

Download from release archive from https://github.com/pocketbase/pocketbase/releases/latest, unzip it and place the `pocketbase` binary in this folder, and you're done.

## custom build

If you would like to extend PocketBase and use it as a framework then there is a `main.go` in this folder that you can customize and build using `go build` or do live development using `modd`.

See https://pocketbase.io/docs/use-as-framework/ for details.

# Setup

## Architecture

> **Note:** For optimal set up, ensure you are using Linux (bare-metal, VM, WSL) or Docker. For other operating systems, you may run into issues, or need additional configuration.
> A docker-compose setup is included with the project, which can be used on any OS.

### TBD: For Windows users

_please contribute if you are a Windows user_

### TBD: For MacOS users

_please contribute if you are a MacOS user_

## Build

Assuming you have Go language tools installed ...

`go build`

If you don't have Go and don't want to install it, you can use docker-compose setup. Otherwise, your only choice is to download the binary from https://github.com/pocketbase/pocketbase/releases/latest, and placing it in this folder. But then you are limited to using JavaScript or configuration (but not Go-language customizations).

## Run migrations

Before you can run the actual backend, you must run the migrations using `./pocketbase migrate up` in the current directory. It will create appropriate schema tables/collections.

## Run the backend

You can run the PocketBase backend direct with `./pocketbase serve` or using `npm run backend` in the `sk` directory. Note that `npm run backend` it is included by default, but if you want the backend to also serve the frontend assets, then you must add the `--publicDir ../frontend/build` option. (Read more about this in [sk/package.json](../sk/package.json).)

## Docker

A highly recommended option is to run it inside a Docker container. A `Dockerfile` is included that builds a production Docker image. Also, a `docker-compose.yml` along with an _override_ file example are included, which should be used during development.

## Active development with `modd`

Finally, if you are going to actively develop using Go using PocketBase as a framework, then you probably want to use [modd](https://github.com/cortesi/modd), a development tool that rebuilds and restarts your Go binary everytime a source file changes (live reload on change). An basic `modd.conf` config file is included in this setup. You can run it by installing `modd` (`go install github.com/cortesi/modd/cmd/modd@latest`) and then running `modd`. All this is done automatically for you if you are using Docker.

# Schema (Collections)

With the 0.9 version of PocketBase, JavaScript auto-migrations as implemented. The JS files in `pb_migrations` can create/drop/modify collections and data. These are executed automatically by PocketBase on startup.

Not only that, they are also generated automatically whenever you change the schema! So go ahead and make changes to the schema and watch new JS files generated in the `pb_migrations` folder. Just remember to commit them to version control.

## Generated Types

The file `generated-types.ts` contains TypeScript definitions of `Record` types mirroring the fields in your database collections. But it needs to be regenerated every time you modify the schema. This can be done by simply running the `typegen` script in the frontend's `package.json`. So remember to do that.

# Hooks

PocketBase provides API's like .OnModelBefore* and .OnModelAfter* to run
callbacks when records change. This app builds on top of that by providing
a "hooks" table that drives those hooks using configuration. It has the
following fields:

- collection: name of the collection that triggers an action
- event: insert/update/delete event that triggers the action
- action_type: "command" if you want to run a program/script or "post" if
  you want to POST to a webhook endpoint. The record will be marshaled to
  JSON and passed to the command as STDIN or to the webhook POST as
  request body (with header 'content-type: application/json')
- action: path to the command/script or URL of the webhook to POST to
- action_params: a string that will be passed as argument to the action

So now by configuring the above table, you can execute external commands/scripts
and POST data to external webhooks in reaction to insert/update/delete of
records.

Most web services these days provide webhook endpoints (e.g. sendgrid, mailchimp, stripe, etc) which you can POST directly to. But if you need special
processing then you can write a script that receives changed data as JSON, parses and manipulates it using [`jq`](https://github.com/stedolan/jq) before
sending it on its way.

See `example-hook-script.sh` for a demonstration.

Possible use cases:

- Send an acknowledgement email when a "contact" form table is inserted to.
- Charge a credit card when payment_token table is inserted to and then
  send email upon success/failure
- Recalculate inventory levels as "orders" table is inserted to, and then
  send notifications when inventory becomes low.


Path: D:\Modible\Software\pocketbase-sveltekit-starter\pb\auditlog\auditlog.go
Contents:
package auditlog

import (
	"log"
	"os"
	"strings"

	"github.com/labstack/echo/v5"
	"github.com/pocketbase/pocketbase"
	"github.com/pocketbase/pocketbase/apis"
	"github.com/pocketbase/pocketbase/core"
	"github.com/pocketbase/pocketbase/models"
	"golang.org/x/exp/slices"
)

// collection names to be audit logged
var collections = strings.Split(os.Getenv("AUDITLOG"), ",")

func Register(app *pocketbase.PocketBase) {
	app.OnBeforeServe().Add(func(e *core.ServeEvent) error {
		app.OnRecordAfterCreateRequest().Add(func(e *core.RecordCreateEvent) error {
			return doAudit(app, "insert", e.Record, e.HttpContext)
		})
		app.OnRecordAfterUpdateRequest().Add(func(e *core.RecordUpdateEvent) error {
			return doAudit(app, "update", e.Record, e.HttpContext)
		})
		app.OnRecordAfterDeleteRequest().Add(func(e *core.RecordDeleteEvent) error {
			return doAudit(app, "delete", e.Record, e.HttpContext)
		})
		return nil
	})
}

func diff(val1, val2 any) bool {
	// handle comparison of non-comparable types
	// TODO: add more cases to the switch below as we discover them
	switch v1 := val1.(type) {
	case []string:
		v2 := val2.([]string)
		if len(v1) != len(v2) {
			return true
		}
		for i, v1 := range v1 {
			if diff(v1, v2[i]) {
				return true
			}
		}
		// no diff, if reached the end of the loop
		return false
	default:
		// use builtin comparison by default
		return val1 != val2
	}
}

func doAudit(app *pocketbase.PocketBase, event string, record *models.Record, ctx echo.Context) error {
	collection := record.Collection().Name
	// exclude logging "auditlog" and include only what's in AUDITLOG env var
	if collection != "auditlog" && slices.Contains(collections, collection) {
		var user, admin string
		if u, ok := ctx.Get(apis.ContextAdminKey).(*models.Admin); ok {
			admin = u.Id
		}
		if u, ok := ctx.Get(apis.ContextAuthRecordKey).(*models.Record); ok {
			user = u.Id
		}
		log.Printf("AuditLog:%s:%s:%s:%s:%s\n", collection, record.Id, event, user, admin)
		target, err := app.Dao().FindCollectionByNameOrId("auditlog")
		if err != nil {
			return err
		}
		auditlog := models.NewRecord(target)
		auditlog.Set("collection", collection)
		auditlog.Set("record", record.Id)
		auditlog.Set("event", event)
		auditlog.Set("user", user)
		auditlog.Set("admin", admin)
		// detect changes
		original := record.OriginalCopy().PublicExport()
		recordExport := record.PublicExport()
		for k, v := range original {
			if !diff(v, recordExport[k]) { // unmodified, then remove
				delete(original, k)
			}
		}
		auditlog.Set("data", recordExport)
		auditlog.Set("original", original)

		return app.Dao().SaveRecord(auditlog)
	}
	return nil
}


Path: D:\Modible\Software\pocketbase-sveltekit-starter\pb\data\email_templates\post.html
Contents:
<p>The following post was updated. Please review it for changes:</p>

<a href="{{ .meta.AppUrl }}/posts/{{ .record.slug }}/">{{ .record.title }}</a>


Path: D:\Modible\Software\pocketbase-sveltekit-starter\pb\hooks\email.go
Contents:
package hooks

import (
	"bytes"
	"encoding/json"
	"errors"
	"net/mail"

	"html/template"

	"github.com/pocketbase/pocketbase"
	"github.com/pocketbase/pocketbase/models"
	"github.com/pocketbase/pocketbase/tools/mailer"
)

var tpls *template.Template

func init() {
	tpls = template.Must(template.ParseGlob("data/email_templates/*"))
}

// set IgnoreEmailVisibilityFlag for the record and it's expanded records (recursively)
func ignoreEmailVisibility(record *models.Record, value bool) {
	record.IgnoreEmailVisibility(value)
	for _, v := range record.Expand() {
		if child, ok := v.(*models.Record); ok {
			// recursively set ...
			ignoreEmailVisibility(child, value)
		}
	}
}

func doEmail(app *pocketbase.PocketBase, action, action_params string, record *models.Record) (err error) {
	// we have to IgnoreEmailVisibility(true) on the main record and all expanded relations in order
	// to include email fields in the exported JSON
	ignoreEmailVisibility(record, true)

	// Export record to JSON and import it back to convert it into map[string]any.
	// Should I use record.PublicExport() instead?
	ba, _ := json.Marshal(record)
	// log.Default().Println(string(ba))
	var _record map[string]any
	json.Unmarshal(ba, &_record)

	// build input data
	data := map[string]any{
		"record": _record,
		"meta":   app.Settings().Meta,
	}

	// populate template expressions within action_params to build params_json
	// example: {"to":"{{ .record.expand.creator.email }}", "subject": "ticket updated - {{ .record.title }}"}
	params_tpl, err := template.New("action_params").Parse(action_params)
	if err != nil {
		return
	}
	var params_json bytes.Buffer
	err = params_tpl.Execute(&params_json, data)
	if err != nil {
		return
	}

	// Unmarshal params_json into params and then inject that into data
	var params map[string]any
	err = json.Unmarshal(params_json.Bytes(), &params)
	if err != nil {
		return
	}
	data["params"] = params

	if _, ok := params["from"]; !ok {
		params["from"] = app.Settings().Meta.SenderName
	}
	if _, ok := params["to"]; !ok {
		return errors.New("action_params must provide 'to' key/value")
	}
	if _, ok := params["subject"]; !ok {
		return errors.New("action_params must provide 'subject' key/value")
	}

	var html bytes.Buffer
	err = tpls.ExecuteTemplate(&html, action, data)
	if err != nil {
		return
	}
	message := mailer.Message{
		From: mail.Address{
			Address: app.Settings().Meta.SenderAddress,
			Name:    params["from"].(string),
		},
		To: []mail.Address{
			{Address: params["to"].(string)},
		},
		Subject: params["subject"].(string),
		HTML:    html.String(),
		// Text:    string(ba),
	}
	return app.NewMailClient().Send(&message)
}


Path: D:\Modible\Software\pocketbase-sveltekit-starter\pb\hooks\hooks.go
Contents:
package hooks

import (
	"encoding/json"
	"fmt"
	"io"
	"log"
	"net/http"
	"os"
	"os/exec"
	"strings"

	"github.com/go-resty/resty/v2"
	"github.com/pocketbase/dbx"
	"github.com/pocketbase/pocketbase"
	"github.com/pocketbase/pocketbase/core"
	"github.com/pocketbase/pocketbase/models"
)

func PocketBaseInit(app *pocketbase.PocketBase) error {
	modelHandler := func(event string) func(e *core.ModelEvent) error {
		return func(e *core.ModelEvent) error {
			table := e.Model.TableName()
			// we don't want to executeEventActions if the event is a system event (e.g. "_collections" changes)
			if record, ok := e.Model.(*models.Record); ok {
				if table == "hooks" {
					log.Println("'hooks' collection changed. Unloading.")
					hookRowsMap = nil // just set it to nil and it will get re-loaded the next time it is needed
				} else {
					executeEventActions(app, event, table, record)
				}
			} else {
				log.Println("Skipping executeEventActions for table:", table)
			}
			return nil
		}
	}
	app.OnBeforeServe().Add(func(e *core.ServeEvent) error {
		// watch insert/update/delete of rows of all collections
		app.OnModelAfterCreate().Add(modelHandler("insert"))
		app.OnModelAfterUpdate().Add(modelHandler("update"))
		app.OnModelAfterDelete().Add(modelHandler("delete"))
		return nil
	})
	return nil
}

// cache of "hooks" table rows (all where disabled=false)
// key=collection:event, value=array-of-rows
var hookRowsMap map[string][]dbx.NullStringMap

func loadHookRows(db *dbx.DB) {
	if hookRowsMap != nil {
		return // already loaded
	}
	hookRowsMap = make(map[string][]dbx.NullStringMap)
	var rows []dbx.NullStringMap
	db.Select("*").
		From("hooks").
		Where(dbx.HashExp{"disabled": false}). // pick rows not disabled only
		All(&rows)
	for _, row := range rows {
		collection := row["collection"].String
		event := row["event"].String
		key := collection + ":" + event
		hookRowsMap[key] = append(hookRowsMap[key], row)
	}
}

func getHookRows(db *dbx.DB, collection, event string) []dbx.NullStringMap {
	loadHookRows(db)
	key := collection + ":" + event
	return hookRowsMap[key]
}

func DoChatGPT(apiKey, prompt string, model string) (string, error) {
	client := resty.New()

	response, err := client.R().
		SetAuthToken(apiKey).
		SetHeader("Content-Type", "application/json").
		SetBody(map[string]interface{}{
			"model":      model,
			"messages":   []interface{}{map[string]interface{}{"role": "system", "content": prompt}},
			"max_tokens": 800,
		}).
		Post("https://api.openai.com/v1/chat/completions")

	if err != nil {
		return "", err
	}

	var data map[string]interface{}
	err = json.Unmarshal(response.Body(), &data)
	if err != nil {
		return "", err
	}

	content := data["choices"].([]interface{})[0].(map[string]interface{})["message"].(map[string]interface{})["content"].(string)
	return content, nil
}

// DoDalle3 generates an image based on the prompt and returns a base64 encoded string.
func DoDalle3(apiKey, prompt, model, size string) (string, error) {
	client := resty.New()

	response, err := client.R().
		SetAuthToken(apiKey).
		SetHeader("Content-Type", "application/json").
		SetBody(map[string]interface{}{
			"model":           model,
			"n":               1,
			"prompt":          prompt,
			"size":            size,
			"response_format": "b64_json",
		}).
		Post("https://api.openai.com/v1/images/generations")

	if err != nil {
		return "", err
	}

	if response.StatusCode() != http.StatusOK {
		return "", fmt.Errorf("unexpected status code: %d, body: %s", response.StatusCode(), response.String())
	}

	// Log the response for debugging purposes
	/* logFile, err := os.OpenFile("api_responses.log", os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0644)
	if err != nil {
		log.Fatal(err)
	}
	defer logFile.Close()
	log.SetOutput(logFile)
	log.Println("response", response.String()) */

	var respBody struct {
		Created int64                    `json:"created"`
		Data    []map[string]interface{} `json:"data"`
	}
	err = json.Unmarshal(response.Body(), &respBody)
	if err != nil {
		return "", err
	}

	if len(respBody.Data) == 0 {
		return "", fmt.Errorf("response data array is empty")
	}
	
	b64Data, ok := respBody.Data[0]["b64_json"].(string)
	if !ok {
		return "", fmt.Errorf("base64 image data not found in response")
	}

	// Here, instead of writing the data to a file, we return the base64 string
	return b64Data, nil
}

func executeEventActions(app *pocketbase.PocketBase, event string, table string, record *models.Record) {
	rows := getHookRows(app.DB(), table, event)
	for _, row := range rows {
		action_type := row["action_type"].String
		action := row["action"].String
		action_params := row["action_params"].String
		expands := strings.Split(row["expands"].String, ",")
		app.Dao().ExpandRecord(record, expands, func(c *models.Collection, ids []string) ([]*models.Record, error) {
			return app.Dao().FindRecordsByIds(c.Name, ids, nil)
		})
		if err := executeEventAction(app, event, table, action_type, action, action_params, record); err != nil {
			log.Println("ERROR", err)
		}
	}
}

func executeEventAction(app *pocketbase.PocketBase, event, table, action_type, action, action_params string, record *models.Record) error {
	log.Printf("event:%s, table: %s, action: %s\n", event, table, action)
	switch action_type {
	case "command":
		return doCommand(action, action_params, record)
	case "post":
		return doPost(action, action_params, record)
	case "email":
		return doEmail(app, action, action_params, record)
	default:
		return fmt.Errorf("unknown action_type: %s", action_type)
	}
}

func doCommand(action, action_params string, record *models.Record) error {
	cmd := exec.Command(action, action_params)
	if w, err := cmd.StdinPipe(); err != nil {
		return err
	} else {
		if r, err := cmd.StdoutPipe(); err != nil {
			return err
		} else {
			go func() {
				defer w.Close()
				defer r.Close()
				log.Println("-------------------------------")
				defer log.Println("-------------------------------")
				if err := cmd.Start(); err != nil {
					log.Printf("command start failed: %s %+v\n", action, err)
				} else {
					// write JSON into the pipe and close
					json.NewEncoder(w).Encode(record)
					w.Close()
					if err := cmd.Wait(); err != nil {
						log.Printf("command wait failed: %s %+v\n", action, err)
					}
				}
			}()
			// read pipe's stdout and copy to ours (in parallel to the above goroutine)
			io.Copy(os.Stdout, r)
		}
	}
	return nil
}

func doPost(action, action_params string, record *models.Record) error {
	r, w := io.Pipe()
	defer w.Close()
	go func() {
		defer r.Close()
		if resp, err := http.Post(action, "application/json", r); err != nil {
			log.Println("POST failed", action, err)
		} else {
			io.Copy(os.Stdout, resp.Body)
		}
	}()
	if err := json.NewEncoder(w).Encode(record); err != nil {
		log.Println("ERROR writing to pipe", err)
	}
	return nil
}

// This function would go in a new or existing file where you manage database interactions.
func processTagsForPost(db *pocketbase.PocketBase, postID string, tagsStr string) error {
	// Split the tags string by comma
	tags := strings.Split(tagsStr, ",")
	uniqueTags := make(map[string]bool)
	for _, tag := range tags {
			// Trim spaces and ensure tag is lowercase for consistency
			cleanTag := strings.ToLower(strings.TrimSpace(tag))
			if cleanTag != "" {
					uniqueTags[cleanTag] = true
			}
	}

	// Here you would interact with your database to find existing tags,
	// create new ones if necessary, and link them to the post via the taggings table.
	// The specifics of these operations depend on how you've set up your models
	// and how you interact with PocketBase collections.

	return nil // Implement error handling based on your logic
}


Path: D:\Modible\Software\pocketbase-sveltekit-starter\pb\pb_hooks\main.pb.ts
Contents:
// Extending PocketBase with JS - @see https://pocketbase.io/docs/js-overview/

/// <reference path="../pb_data/types.d.ts" />

routerAdd("GET", "/api/goodbye/:name", (c) => {
  let name = c.pathParam("name");
  return c.json(200, { message: "Goodbye " + name });
});

// sends email to the logged in user
routerAdd(
  "POST",
  "/api/sendmail",
  (c) => {
    const user = c.get("authRecord"); // obtain user record from context
    user.ignoreEmailVisibility(true); // required for user.get("email")
    const address = user.get("email"); // works only after user.ignoreEmailVisibility(true)
    const name = user.get("name");
    const message = new MailerMessage({
      from: {
        address: $app.settings().meta.senderAddress,
        name: $app.settings().meta.senderName,
      },
      to: [{ name, address }],
      subject: `test email from ${name}`,
      text: "Test email",
      html: "<strong>Test</strong> <em>email</em>",
    });
    $app.newMailClient().send(message);

    return c.json(200, { message });
  },
  // middleware(s)
  $apis.requireRecordAuth("users")
);


Path: D:\Modible\Software\pocketbase-sveltekit-starter\sk\.prettierignore
Contents:
.DS_Store
node_modules
/build
/.svelte-kit
/package
.env
.env.*
!.env.example

# Ignore files for PNPM, NPM and YARN
pnpm-lock.yaml
package-lock.json
yarn.lock


Path: D:\Modible\Software\pocketbase-sveltekit-starter\sk\.prettierrc
Contents:
{
  "useTabs": false,
  "singleQuote": false,
  "trailingComma": "es5",
  "printWidth": 80,
  "pluginSearchDirs": ["."],
  "overrides": [
    {
      "files": "*.svelte",
      "options": {
        "parser": "svelte"
      }
    }
  ],
  "plugins": ["prettier-plugin-tailwindcss"]
}


Path: D:\Modible\Software\pocketbase-sveltekit-starter\sk\playwright.config.ts
Contents:
import type { PlaywrightTestConfig } from "@playwright/test";

const config: PlaywrightTestConfig = {
  use: {
    headless: false,
    // viewport: { width: 1280, height: 768 },
    // video: "on-first-retry",
    // make sure "npm run dev" is running for localhost:5173 to work
    baseURL: "http://localhost:8090",
  },
  reporter: [["html"]],
};

export default config;


Path: D:\Modible\Software\pocketbase-sveltekit-starter\sk\postcss.config.cjs
Contents:
const tailwindcss = require("tailwindcss");
const autoprefixer = require("autoprefixer");

const config = {
  plugins: [
    //Some plugins, like tailwindcss/nesting, need to run before Tailwind,
    tailwindcss(),
    //But others, like autoprefixer, need to run after,
    autoprefixer,
  ],
};

module.exports = config;


Path: D:\Modible\Software\pocketbase-sveltekit-starter\sk\README.md
Contents:
# Static SvekteKit frontend for PocketBase backend

## Setup

```bash
npx pnpm install # install dependencies
npm run build # compile frontend
```

The above produces `build` output directory which is then used by PocketBase to serve the frontend of your app.

## Live Development

```bash
# start the backend, if not already running ...
npm run dev:backend
# and then start the frontend ...
npm run dev
```

Now visit http://localhost:5173 (sk) or http://localhost:8090 (pb)

## Generated Types

The file `generated-types.ts` contains TypeScript definitions of `Record` types mirroring the fields in your database collections. But it needs to be regenerated every time you modify the schema. This can be done by simply running the `typegen` script in the frontend's `package.json`. So remember to run `npm run typegen` after every schema change.

## Building

To create a production version of your app (static HTML/JS app):

_NOTE_: The build below will fail unless the backend has at least 1
post created. So please create a "posts" record using the app UI or
the admin UI before running build below.

```bash
# compile frontend
npm run build
# and then serve it with pocketbase
npm run backend
```

The above generates output in the `build` folder. Now you can serve production compiled version of the frontend using the backend (with `--publicDir ../frontend/build`), any static file web server, or `npm preview`.


Path: D:\Modible\Software\pocketbase-sveltekit-starter\sk\svelte.config.js
Contents:
import { vitePreprocess } from "@sveltejs/vite-plugin-svelte";
import adapter from "@sveltejs/adapter-static";
import preprocess from "svelte-preprocess";

/** @type {import('@sveltejs/kit').Config} */
const config = {
  preprocess: [
    preprocess({
      postcss: true,
    }),
    vitePreprocess(),
  ],

  kit: {
    adapter: adapter({
      pages: "build",
      assets: "build",
      fallback: "index.html",
      precompress: true,
      strict: true,
    }),
    paths: {
      base: process.env.BASE_PATH ?? "",
    },
    alias: {
      $lib: "src/lib",
    },
    prerender: {
      entries: ['*', '/posts/[slug]'],
    },
  },
};

export default config;


Path: D:\Modible\Software\pocketbase-sveltekit-starter\sk\tailwind.config.cjs
Contents:
const daisyui = require("daisyui");
const typography = require("@tailwindcss/typography");
const forms = require("@tailwindcss/forms");

/** @type {import('tailwindcss').Config}*/
const config = {
  content: ["./src/**/*.{html,js,svelte,ts}"],

  theme: {
    extend: {},
  },

  plugins: [forms, typography, daisyui],

  daisyui: {
    themes: [
      "light",
      "dark",
      "cupcake",
      "bumblebee",
      "emerald",
      "corporate",
      "synthwave",
      "retro",
      "cyberpunk",
      "valentine",
      "halloween",
      "garden",
      "forest",
      "aqua",
      "lofi",
      "pastel",
      "fantasy",
      "wireframe",
      "black",
      "luxury",
      "dracula",
      "cmyk",
      "autumn",
      "business",
      "acid",
      "lemonade",
      "night",
      "coffee",
      "winter",
      "dim",
      "nord",
      "sunset",
    ],
  },
};

module.exports = config;


Path: D:\Modible\Software\pocketbase-sveltekit-starter\sk\tsconfig.json
Contents:
{
  "extends": "./.svelte-kit/tsconfig.json",
  "compilerOptions": {
    "allowJs": true,
    "checkJs": true,
    "esModuleInterop": true,
    "forceConsistentCasingInFileNames": true,
    "resolveJsonModule": true,
    "skipLibCheck": true,
    "sourceMap": true,
    "strict": true
  }
  // Path aliases are handled by https://kit.svelte.dev/docs/configuration#alias
  //
  // If you want to overwrite includes/excludes, make sure to copy over the relevant includes/excludes
  // from the referenced tsconfig.json - TypeScript does not merge them in
}


Path: D:\Modible\Software\pocketbase-sveltekit-starter\sk\vite.config.ts
Contents:
import { sveltekit } from "@sveltejs/kit/vite";
import type { UserConfig } from "vite";
import fs from "fs";

// detect if we're running inside docker and set the backend accordingly
const pocketbase_url = fs.existsSync("/.dockerenv")
  ? "http://pb:8090" // docker-to-docker
  : "http://localhost:8090"; // localhost-to-localhost

const config: UserConfig = {
  plugins: [sveltekit()],
  server: {
    proxy: {
      // proxy "/api" and "/_" to pocketbase_url
      "/api": pocketbase_url,
      "/_": pocketbase_url,
    },
  },
};

export default config;


Path: D:\Modible\Software\pocketbase-sveltekit-starter\sk\src\app.d.ts
Contents:
import type { PocketBase } from "pocketbase"

declare global {
  namespace App {
    interface Locals {
      pb: PocketBase;
    }
  }
}

declare namespace App {
  export interface PageData {
    post?: {
      id: string;
      title: string;
      slug: string;
      body: string;
      tags: string[];
      blogSummary: string;
      featuredImage: string;
      userid: string;
      prompt: string;
    };
    featuredImageUrl?: string;
  }
}

Path: D:\Modible\Software\pocketbase-sveltekit-starter\sk\src\app.html
Contents:
<!doctype html>
<html lang="en" class="h-full" data-theme="dark">
  <head>
    <meta charset="utf-8" />
    <link rel="icon" href="%sveltekit.assets%/favicon.ico" />
    <meta name="viewport" content="width=device-width" />
    %sveltekit.head%
  </head>
  <body class="h-full">
    <div>%sveltekit.body%</div>
  </body>
</html>


Path: D:\Modible\Software\pocketbase-sveltekit-starter\sk\src\app.pcss
Contents:



Path: D:\Modible\Software\pocketbase-sveltekit-starter\sk\src\app.scss
Contents:
/* Write your global styles here, in PostCSS syntax */
@tailwind base;
@tailwind components;
@tailwind utilities;

Path: D:\Modible\Software\pocketbase-sveltekit-starter\sk\src\lib\config.ts
Contents:
export const site = {
  name: "mind",
  source_url: "https://modible.com/mind",
  description:
    "Capture your inspiration and ideas with mind. A simple and elegant journaling app that helps you stay organized.",
};


Path: D:\Modible\Software\pocketbase-sveltekit-starter\sk\src\lib\app\stores.ts
Contents:
import { writable } from "svelte/store";

export interface Metadata {
  title?: string;
  description?: string;
  headline?: string;
}

export const metadata = writable<Metadata>({});


Path: D:\Modible\Software\pocketbase-sveltekit-starter\sk\src\lib\components\Alerts.svelte
Contents:
<script lang="ts" context="module">
import { writable } from "svelte/store";

interface Alert {
  message: string;
  type: string;
  timeout?: number;
  html?: boolean;
}

export const alerts = {
  ...writable<Alert[]>([]),
  add({ message, type = "info", timeout = 0, html = false }: Alert) {
    const alert = { message, type, html };
    this.update((v) => [...v, alert]);
    if (timeout) {
      setTimeout(() => {
        dismiss(alert);
      }, timeout);
    }
  },
  info(message: string, timeout = 0) {
    this.add({ message, type: "info", timeout });
  },
  success(message: string, timeout = 0) {
    this.add({ message, type: "success", timeout });
  },
  warning(message: string, timeout = 0) {
    this.add({ message, type: "warning", timeout });
  },
  error(message: string, timeout = 0) {
    this.add({ message, type: "error", timeout });
  },
};

export function errorAlert(message: string) {
  const type = "error";
}

function dismiss(alert: Alert) {
  alerts.update((val) => val.filter((a) => a !== alert));
}

function dismissAll() {
  alerts.set([]);
}
</script>

<svelte:window
  on:unhandledrejection={(e) => alerts.error(e.reason.toString())}
/>

<article>
  {#if $alerts.length > 1}
    <button on:click={dismissAll} class="tight">Dismiss All</button>
  {/if}
  {#each $alerts as alert}
    <blockquote class={alert.type}>
      <button on:click={() => dismiss(alert)} class="dismiss">&times;</button>
      {#if alert.html}
        {@html alert.message}
      {:else}
        {alert.message}
      {/if}
    </blockquote>
  {/each}
</article>

<style>
</style>


Path: D:\Modible\Software\pocketbase-sveltekit-starter\sk\src\lib\components\DateShow.svelte
Contents:
<script lang="ts">
export let date: string;
let dt: Date,
  // year: number,
  // dom: number,
  // dow: number,
  // mon: number,
  year: string,
  dom: string,
  dowName: string,
  monName: string;
const days = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"];

$: {
  dt = new Date(date);
  // year = dt.getFullYear();
  // dom = dt.getDate();
  // dow = dt.getDay();
  // mon = dt.getMonth();
  [dowName, monName, dom, year] = dt.toDateString().split(" ");
}
</script>

<div class="date" title={dt.toLocaleString()}>
  <div class="dow">{dowName}</div>
  <div>
    <div class="mon">{monName}</div>
    <div class="dom">{dom}</div>
  </div>
  <div class="year">{year}</div>
</div>

<style lang="scss">
.date {
  display: inline-flex;
  background-color: var(--border);
  border-radius: 50%;
  height: 5em;
  aspect-ratio: 1;
  padding: 0.5em;
  flex-direction: column;
  justify-content: center;
  align-items: center;
  font-family: var(--font-alt);
  > div {
    display: flex;
    flex-direction: row;
    gap: 0.25em;
    > * {
      font-weight: bold;
    }
  }
}
</style>


Path: D:\Modible\Software\pocketbase-sveltekit-starter\sk\src\lib\components\Delete.svelte
Contents:
<script lang="ts">
import { goto } from "$app/navigation";
import { client } from "$lib/pocketbase";
import { alertOnFailure } from "$lib/pocketbase/ui";

export let id: string;
export let table: string;
async function submit() {
  alertOnFailure(async () => {
    console.log(
      `Attempting to delete record with ID: ${id} from table: ${table}`
    );
    await client.collection(table).delete(id);
    goto("/remember");
  });
}
</script>

<form on:submit|preventDefault={submit}>
  <article>
    <aside>Are you sure you want to delete the following record?</aside>
  </article>
  <button type="submit">Yes - Proceed</button>
  <button type="reset" on:click={() => goto("/remember")}>No - Cancel</button>
</form>


Path: D:\Modible\Software\pocketbase-sveltekit-starter\sk\src\lib\components\Dialog.svelte
Contents:
<script lang="ts">
  export let open: boolean;

  function handleClose() {
    open = false;
  }
</script>

<dialog class="modal" {open} on:close={handleClose}>
  <div class="modal-box">
    <slot />    
    <div class="modal-action">
      <button class="btn btn-primary" on:click={handleClose}>Close</button>
    </div>
  </div>
</dialog>

<style>
  /* Add any necessary styles */
</style>

Path: D:\Modible\Software\pocketbase-sveltekit-starter\sk\src\lib\components\FileInput.svelte
Contents:
<script lang="ts">
import { createEventDispatcher } from "svelte";

export let files: FileList;
export let accept = ".*";
export let multiple = true;
export let pasteFile = false;
const dispatch = createEventDispatcher();
function paste(e: ClipboardEvent) {
  if (pasteFile && e.clipboardData?.files) {
    files = e.clipboardData.files;
    dispatch("change", files);
  }
}
</script>

<svelte:body on:paste={paste} />

<label class="file">
  <div><slot>Drag/drop files here.</slot></div>
  <input
    type="file"
    multiple={multiple}
    bind:files={files}
    on:change={(e) => dispatch("change", files)}
    accept={accept}
  />
</label>

<style lang="scss">
label.file {
  cursor: pointer;
  border: dashed 2px gray;
  padding: 1em;
  position: relative;
  display: flex;
  justify-content: center;
  input[type="file"] {
    position: absolute;
    width: 100%;
    height: 100%;
    top: 0;
    bottom: 0;
    left: 0;
    right: 0;
    opacity: 0;
    padding: 0;
    margin: 0;
    cursor: pointer;
  }
}
</style>


Path: D:\Modible\Software\pocketbase-sveltekit-starter\sk\src\lib\components\Image.svelte
Contents:
<script lang="ts">
  import { client } from "$lib/pocketbase";
  import type { PostsResponse } from "$lib/pocketbase/generated-types";

  export let post: PostsResponse;
  export let alt: string = "";
  export let className: string = "";

  let imageUrl: string = "";

  async function loadImage() {
    if (post.expand?.featuredImage) {
      const image = post.expand.featuredImage as { file: string };
      
      if (image && image.file) {
      imageUrl = client.getFileUrl(post, image.file);
      }
    } else if (post.featuredImage) {
      const image = await client.collection("images").getOne(post.featuredImage);
      if (image && image.file) {
        imageUrl = client.getFileUrl(image, image.file);
      }
    }
  }

  $: {
    if (post) {
      loadImage();
    }
  }
</script>

{#if imageUrl}
  <img src={imageUrl} {alt} class={className} />
{:else}
  <img src="https://via.placeholder.com/800x400.png?text=No+Image" {alt} class={className} />
{/if}

Path: D:\Modible\Software\pocketbase-sveltekit-starter\sk\src\lib\components\InterpretationList.svelte
Contents:
<script lang="ts">
    import { createEventDispatcher } from "svelte";
  
    export let interpretations: string[];
  
    const dispatch = createEventDispatcher();
  
    function selectInterpretation(interpretation: string) {
      dispatch("select", { interpretation });
    }
  
    function goBack() {
      dispatch("back");
    }
  </script>
  
  <div class="container mx-auto p-4">
    <div class="mb-6">
      <h2 class="text-2xl font-semibold mb-4">Select an interpretation:</h2>
      <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
        {#each interpretations as interpretation}
          <div class="card bg-base-100 shadow-xl">
            <div class="card-body">
              <p class="card-title">{interpretation}</p>
              <div class="card-actions justify-end">
                <button class="btn btn-primary" on:click={() => selectInterpretation(interpretation)}>
                  Select
                </button>
              </div>
            </div>
          </div>
        {/each}
      </div>
    </div>
    <button class="btn btn-secondary" on:click={goBack}>Back</button>
  </div>

Path: D:\Modible\Software\pocketbase-sveltekit-starter\sk\src\lib\components\LoadingIndicator.svelte
Contents:
<script lang="ts">
    export let message: string;
  </script>
  
  <div>
    <svg
      class="h-8 w-8 animate-spin text-gray-800"
      xmlns="http://www.w3.org/2000/svg"
      fill="none"
      viewBox="0 0 24 24"
    >
      <circle
        class="opacity-25"
        cx="12"
        cy="12"
        r="10"
        stroke="currentColor"
        stroke-width="4"
      ></circle>
      <path
        class="opacity-75"
        fill="currentColor"
        d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"
      ></path>
    </svg>
    <p class="text-lg font-medium">{message}</p>
    <progress class="progress progress-primary w-56" value="1" max="100"></progress>
  </div>

Path: D:\Modible\Software\pocketbase-sveltekit-starter\sk\src\lib\components\LoginBadge.svelte
Contents:
<script lang="ts">
  import { onMount, onDestroy } from 'svelte';
  import { authModel, client } from '../pocketbase';
  import Dialog from './Dialog.svelte';
  import LoginForm from './LoginForm.svelte';
  import { goto } from '$app/navigation';
  
  let isDialogOpen = false;
  let isDropdownOpen = false;
  
  async function logout() {
    goto('/');
    client.authStore.clear();
    isDialogOpen = false;
    isDropdownOpen = false; // Ensure dropdown is closed on logout
  }
  
  function getFileUrl(authModel, avatar) {
    const baseUrl = import.meta.env.VITE_APP_BASE_URL + '/api/files/_pb_users_auth_';
    const userId = authModel.id;
    const fileName = avatar;
    const token = client.authStore.token;
  
    return `${baseUrl}/${userId}/${fileName}?token=${token}`;
  }
  
  const unsubscribe = client.authStore.onChange((token, model) => {
    // Handle auth state changes
  }, false);
  
  onDestroy(() => {
    unsubscribe();
  });
  </script>
  
 <!-- Display user information and dropdown toggle -->
{#if $authModel}
<div class="relative inline-block text-left">
  <button class="dropdown" on:click={() => (isDropdownOpen = !isDropdownOpen)} aria-haspopup="true" aria-expanded={isDropdownOpen}>
    <div tabindex="0" role="button" class="btn mb-1">
      {$authModel?.name || $authModel?.username || 'User'}
      <i class="fas fa-chevron-down"></i>
    </div>
  </button>
  {#if isDropdownOpen}
    <ul class="dropdown-content z-[1] menu p-2 shadow bg-base-200 rounded-box w-52 absolute right-0 mt-2">
      <li><button class="justify-between" on:click={() => (isDialogOpen = true)}>Profile</button></li>
      <!-- Add more dropdown items here -->
      <li>
        <button class="flex" title="View profile">
          <img alt="Profile" src="/avatar.png" class="w-8 rounded-full" />
          <div class="flex flex-col">
            <h3 class="font-bold">User name</h3>
            <span class="text-xs text-accent">username@email.com</span>
          </div>
        </button>
      </li>
      <div class="divider my-0"></div>
      <li><button>Settings</button></li>
      <li><button>Keyboard shortcut</button></li>
      <div class="divider my-0"></div>
      <li><button>Company profile</button></li>
      <li><button>Team</button></li>
      <li><button>Invite Colleagues</button></li>
      <div class="divider my-0"></div>
      <li><button>Help</button></li>
      <li><button on:click={logout}>Sign out</button></li>
    </ul>
  {/if}
</div>
{:else}
<button class="btn btn-primary" on:click={() => (isDialogOpen = true)}>Sign In</button>
{/if}

<Dialog bind:open={isDialogOpen}>
{#if $authModel}
  <!-- Logged in user's profile or logout option -->
  <div>
    <button on:click={logout}>Sign Out</button>
  </div>
{:else}
  <!-- Login form for users who are not logged in -->
  <LoginForm />
{/if}
</Dialog>

Path: D:\Modible\Software\pocketbase-sveltekit-starter\sk\src\lib\components\LoginForm.svelte
Contents:
<script lang="ts">
export let authCollection = "users";
export let passwordLogin = true;
export let signup = true;
import { client, providerLogin } from "../pocketbase";
const coll = client.collection(authCollection);
let email: string;
let name: string;
let password: string;
let passwordConfirm: string;
let create = false;
let admin = false;
let activeTab = signup ? "SignUp" : "SignIn";
let errorMessage = "";
let successMessage = "";
async function submit() {
  if (create) {
    try {
      await coll.create({ email, name, password, passwordConfirm });
      successMessage = "User created successfully!";
      errorMessage = "";
    } catch (error) {
      console.error("Error creating user:", error);
      errorMessage = "Error creating user. Please try again.";
      successMessage = "";
    }
  } else if (admin) {
    try {
      await client.admins.authWithPassword(email, password);
      successMessage = "Admin authenticated successfully!";
      errorMessage = "";
    } catch (error) {
      console.error("Admin authentication error:", error);
      errorMessage =
        "Admin authentication failed. Please check your credentials.";
      successMessage = "";
    }
  } else {
    try {
      await coll.authWithPassword(email, password);
      successMessage = "User authenticated successfully!";
      errorMessage = "";
    } catch (error) {
      console.error("User authentication error:", error);
      errorMessage =
        "User authentication failed. Please check your credentials.";
      successMessage = "";
    }
  }
}
</script>

<form
  on:submit|preventDefault={submit}
  class="rounded-box bg-base-200 flex max-w-md flex-col gap-4 p-6"
>
  {#if passwordLogin}
    <h1 class="self-center text-3xl font-bold">
      {activeTab === 'SignIn' ? 'Log in' : 'Create an account'}
    </h1>

    <div class="tabs self-center">
      <button
        class="tab tab-bordered {activeTab === 'SignIn' ? 'tab-active' : ''}"
        on:click={() => (activeTab = 'SignIn', signup = false)}
        on:keydown={(event) => {
          if (event.key === 'Enter') {
            activeTab = 'SignIn';
            signup = false;
          }
        }}
        aria-label="Log in"
        type="button"
      >
        Log in
      </button>
      <button
        class="tab tab-bordered {activeTab === 'SignUp' ? 'tab-active' : ''}"
        on:click={() => (activeTab = 'SignUp', signup = true)}
        on:keydown={(event) => {
          if (event.key === 'Enter') {
            activeTab = 'SignUp';
            signup = true;
          }
        }}
        aria-label="Sign up"
      >
        Sign up
      </button>
    </div>

    {#await coll.listAuthMethods({ $autoCancel: false }) then methods}
      <div class="space-y-2">
        {#each methods.authProviders as p}
          <button
            class="btn btn-neutral w-full"
            type="button"
            on:click={() => providerLogin(p, coll)}
          >
            <i class="fa-brands fa-google text-primary mr-2"></i>
            {activeTab === 'SignIn' ? 'Log in' : 'Sign up'} with {p.name}
          </button>
        {/each}
      </div>
    {:catch}
      <!-- pocketbase not working -->
    {/await}

    <div class="divider">OR</div>

    {#if activeTab === 'SignIn'}
      <label class="form-control">
        <div class="label">
          <span class="label-text">Email</span>
        </div>
        <input
          class="input input-bordered"
          bind:value={email}
          required
          type="email"
          placeholder="email"
          id="email-input"
          autocomplete="email"
        />
      </label>

      <label class="form-control">
        <div class="label">
          <span class="label-text">Password</span>
        </div>
        <input
          class="input input-bordered"
          bind:value={password}
          required
          type="password"
          placeholder="password"
          id="password-input"
          autocomplete="current-password"
        />
      </label>

      <div class="form-control">
        <label class="label cursor-pointer gap-2 self-start">
          <input type="checkbox" class="checkbox" bind:checked={admin} />
          <span class="label-text">Admin</span>
        </label>
      </div>

      <button
        class="btn btn-primary"
        type="submit"
        on:click={() => (create = false)}
      >
        Log in
      </button>
    {:else if activeTab === 'SignUp'}
      <label class="form-control">
        <div class="label">
          <span class="label-text">Email</span>
        </div>
        <input
          class="input input-bordered"
          bind:value={email}
          required
          type="text"
          placeholder="email"
        />
      </label>

      <label class="form-control">
        <div class="label">
          <span class="label-text">Password</span>
        </div>
        <input
          class="input input-bordered"
          bind:value={password}
          required
          type="password"
          placeholder="password"
        />
      </label>

      <label class="form-control">
        <div class="label">
          <span class="label-text">Confirm password</span>
        </div>
        <input
          class="input input-bordered"
          bind:value={passwordConfirm}
          required
          type="password"
          placeholder="confirm password"
        />
      </label>

      <label class="form-control">
        <div class="label">
          <span class="label-text">Name / Label</span>
        </div>
        <input
          class="input input-bordered"
          bind:value={name}
          required
          type="text"
          placeholder="name / label"
        />
      </label>

      <input type="hidden" name="register" value={true} />

      <button
        class="btn btn-primary"
        type="submit"
        on:click={() => (create = true)}
      >
        Sign up
      </button>
    {/if}

    {#if errorMessage}
      <div class="alert alert-error">
        <div class="flex-1">
          <svg
            xmlns="http://www.w3.org/2000/svg"
            fill="none"
            viewBox="0 0 24 24"
            class="mx-2 h-6 w-6 stroke-current"
          >
            <path
              stroke-linecap="round"
              stroke-linejoin="round"
              stroke-width="2"
              d="M18.364 18.364A9 9 0 005.636 5.636m12.728 12.728A9 9 0 015.636 5.636m12.728 12.728L5.636 5.636"
            ></path>
          </svg>
          <label>{errorMessage}</label>
        </div>
      </div>
    {/if}

    {#if successMessage}
      <div class="alert alert-success">
        <div class="flex-1">
          <svg
            xmlns="http://www.w3.org/2000/svg"
            fill="none"
            viewBox="0 0 24 24"
            class="mx-2 h-6 w-6 stroke-current"
          >
            <path
              stroke-linecap="round"
              stroke-linejoin="round"
              stroke-width="2"
              d="M3 7v10a2 2 0 002 2h14a2 2 0 002-2V9a2 2 0 00-2-2h-6l-2-2H5a2 2 0 00-2 2z"
            ></path>
          </svg>
          <label>{successMessage}</label>
        </div>
      </div>
    {/if}
  {/if}
</form>


Path: D:\Modible\Software\pocketbase-sveltekit-starter\sk\src\lib\components\LoginGuard.svelte
Contents:
<script lang="ts">
import { goto } from "$app/navigation";
import { Admin } from "pocketbase";
import { authModel } from "../pocketbase";
import LoginForm from "./LoginForm.svelte";
export let admin: boolean | undefined = undefined;
export let slotLogin = false;
export let destination: string | null = null;
$: if (destination != null && $authModel) {
  goto(destination);
}
$: authorized =
  $authModel && //  must be logged in
  (admin === undefined || // admin or not, doesn't matter
    (admin === true && $authModel instanceof Admin) || // must be admin
    (admin === false && !($authModel instanceof Admin))); // must not be admin
</script>

{#if authorized}
  <slot />
{:else if slotLogin || $$slots["login"]}
  <slot name="login">
    <LoginForm />
  </slot>
{/if}


Path: D:\Modible\Software\pocketbase-sveltekit-starter\sk\src\lib\components\Nav.svelte
Contents:
<script lang="ts">
  import { base } from "$app/paths";
  import { page } from "$app/stores";
  import LoginBadge from "$lib/components/LoginBadge.svelte";
  import { authModel } from "$lib/pocketbase";
  import ThemeSwitch from "$lib/components/ThemeSwitch.svelte";

  const appLinks = [
    ["/create/", "Create"],
    ["/remember/", "Remember"],
    ["/inspire/", "Inspire"],
    ["/explore/", "Explore"],
    ["/reflect/", "Reflect"],
  ];

  const landingLinks = [
    ["/#features", "Features"],
    ["/#how-it-works", "How It Works"],
    ["/#pricing", "Pricing"],
    ["/#testimonials", "Testimonials"],
    ["/#contact", "Contact"],
  ];
</script>

<nav>
  <div class="navbar">
    <div class="navbar-start">
      <details class="dropdown">
        <summary class="btn btn-ghost lg:hidden">
          <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h8m-8 6h16" />
          </svg>
        </summary>
        
        <ul class="menu menu-compact dropdown-content mt-3 p-2 shadow rounded-box w-52">
          {#if $authModel}
            {#each appLinks as [path, label]}
              <li>
                <a href={`${base}${path}`} class:active="{$page.url.pathname === path}">{label}</a>
              </li>
            {/each}
          {:else}
            {#each landingLinks as [path, label]}
              <li>
                <a href={path}>{label}</a>
              </li>
            {/each}
          {/if}
        </ul>
        <ThemeSwitch></ThemeSwitch>
      </details>
      <a href="/" class="btn btn-ghost normal-case text-xl">mind.ai</a>
    </div>
    <div class="navbar-center hidden lg:flex">
      
      <ul class="menu menu-horizontal p-0">
        {#if $authModel}
          {#each appLinks as [path, label]}
            <li class="p-4">
              <a href={`${base}${path}`} class:active="{$page.url.pathname === path}">{label}</a>
            </li>
          {/each}
        {:else}
          {#each landingLinks as [path, label]}
            <li class="p-4">
                <a href={path}>{label}</a>
            </li>
          {/each}
        {/if}
      </ul>
    </div>
    <ThemeSwitch></ThemeSwitch>
    <div class="navbar-end">
      <LoginBadge />
    </div>
  </div>
</nav>


Path: D:\Modible\Software\pocketbase-sveltekit-starter\sk\src\lib\components\PostCard.svelte
Contents:
<script lang="ts">
    import type { PostsResponse } from "$lib/pocketbase/generated-types";
    import Markdown from "svelte-markdown";
    import TagGroup from "$lib/components/TagGroup.svelte";
    import { client } from "$lib/pocketbase";
  
    export let post: PostsResponse;
  
    async function getFeaturedImageUrl(post: any) {
      if (post.featuredImage) {
        const image = await client.collection("images").getOne(post.featuredImage);
        if (image && image.file) {
          return client.getFileUrl(image, image.file);
        }
      }
      return "https://via.placeholder.com/800x400.png?text=AI+Blog";
    }
  </script>
  
  <div class="card  flex flex-col justify-between p-4 shadow-xl">
    <div>
      <figure class="relative">
        {#await getFeaturedImageUrl(post)}
          <img
            src="https://via.placeholder.com/800x400.png?text=Loading..."
            alt="Loading..."
            class="aspect-[16/9] w-full object-cover sm:aspect-[2/1] lg:aspect-[3/2]"
          />
        {:then featuredImageUrl}
          <img
            src={featuredImageUrl}
            alt={post.title}
            class="aspect-[16/9] w-full object-cover sm:aspect-[2/1] lg:aspect-[3/2]"
          />
        {/await}
      </figure>
      <div class="mt-4">
        <div class="prose items-center gap-x-4">
          <time datetime={post.updated} class="text-accent">
            {new Date(post.updated).toLocaleDateString()}
          </time>
        </div>
        <div class="group relative mt-3">
          <a
            href={`/posts/${post.slug}`}
            class="prose-lg text-primary line-clamp-2 font-bold"
          >
            {post.title}
          </a>
          <div class="prose-sm text-base-content mt-3 line-clamp-6">
            <Markdown source={post.blogSummary} />
          </div>
        </div>
      </div>
      <TagGroup post={post} />
    </div>
  
    <div class="mt-4 flex justify-between">
      <a class="btn btn-outline" href={`/posts/${post.slug}/edit`}>Edit</a>
      <a class="btn btn-outline btn-secondary" href={`/posts/${post.slug}#delete`}>Delete</a>
    </div>
  </div>

Path: D:\Modible\Software\pocketbase-sveltekit-starter\sk\src\lib\components\PostContent.svelte
Contents:
<script lang="ts">
    import { marked } from "marked";
  
    export let content: string;
  </script>
  
  <div class="mt-4">
    {@html marked(content || "")}
  </div>

Path: D:\Modible\Software\pocketbase-sveltekit-starter\sk\src\lib\components\PostList.svelte
Contents:
<script lang="ts">
import type { PostsResponse } from "$lib/pocketbase/generated-types";
import PostCard from "./PostCard.svelte";
export let posts: PostsResponse[];
import { client, authModel } from "$lib/pocketbase";
import { alertOnFailure } from "$lib/pocketbase/ui";

async function deleteAllPosts() {
  alertOnFailure(async () => {
    const postsResponse = await client.collection("posts").getList();
    for (const post of postsResponse.items) {
      await client.collection("posts").delete(post.id);
    }
    // Optionally, refresh the posts list or navigate as needed
  });
}
</script>

<div
  class="grid grid-cols-1 gap-x-2 gap-y-20 overflow-y-auto p-4 lg:grid-cols-3"
  style="max-height: calc(100vh - 15rem);"
>
  {#if posts.length > 0}
    {#each posts as post}
      <PostCard post={post} />
    {/each}
  {:else}
    <div class="col-span-full py-8 text-center">No posts found.</div>
  {/if}
</div>

{#if $authModel}
  <div class="my-4 text-right">
    <button class="btn btn-error ml-2" on:click={deleteAllPosts}>
      Delete All Posts
    </button>
  </div>
{:else}
  <div class="my-4 text-center">
    <p>Please login to manage posts.</p>
  </div>
{/if}


Path: D:\Modible\Software\pocketbase-sveltekit-starter\sk\src\lib\components\ServiceForm.svelte
Contents:
<script lang="ts">
    import { createEventDispatcher } from 'svelte';
  
    const dispatch = createEventDispatcher();
    let selectedService = '';
    let selectedModel = '';
    let inputText = '';
  
    const services = [
      {
        name: "Anthropic",
        models: [
          "claude-3-haiku-20240307",
          "claude-3-sonnet-20240229",
          "claude-3-opus-20240229",
          "claude-2.1",
          "claude-2.0",
          "claude-instant-1.2",
        ],
      },
      {
        name: "OpenAI",
        models: ["gpt-4-turbo-preview", "gpt-3.5-turbo"],
      },
    ];
  
    async function callAPI() {
      // Emit an event with the selected service, model, and input text
      dispatch('submit', { selectedService, selectedModel, inputText });
    }
  </script>
  
  <div>
    <select bind:value={selectedService}>
      <option value="">Select a service</option>
      {#each services as service}
        <option value={service.name}>{service.name}</option>
      {/each}
    </select>
  
    {#if selectedService}
      <select bind:value={selectedModel}>
        <option value="">Select a model</option>
        {#each services.find(s => s.name === selectedService)?.models ?? [] as model}
          <option value={model}>{model}</option>
        {/each}
      </select>
    {/if}
  
    <input type="text" bind:value={inputText} placeholder="Enter text" />
    <button on:click={callAPI} disabled={!selectedService || !selectedModel}>
      Submit
    </button>
  </div>

Path: D:\Modible\Software\pocketbase-sveltekit-starter\sk\src\lib\components\ServiceSelector.svelte
Contents:
<script lang="ts">
    export let selectedService: string;
    export let selectedModel: string;
  
    const services = [
      {
        name: "Anthropic",
        models: [
          "claude-3-haiku-20240307",
          "claude-3-sonnet-20240229",
          "claude-3-opus-20240229",
          "claude-2.1",
          "claude-2.0",
          "claude-instant-1.2",
        ],
      },
      {
        name: "OpenAI",
        models: ["gpt-4-turbo-preview", "gpt-3.5-turbo"],
      },
    ];
  </script>
  
  <div>
    <select
      class="select select-ghost w-full max-w-xs"
      bind:value={selectedService}
    >
      {#each services as service, i}
        <option value={service.name} selected={i === 0}>{service.name}</option>
      {/each}
    </select>
  
    {#if selectedService}
      <select
        class="select select-ghost w-full max-w-xs"
        bind:value={selectedModel}
      >
        {#each services.find(s => s.name === selectedService)?.models ?? [] as model, i}
          <option value={model} selected={i === 0}>{model}</option>
        {/each}
      </select>
    {/if}
  </div>

Path: D:\Modible\Software\pocketbase-sveltekit-starter\sk\src\lib\components\Spinner.svelte
Contents:
<script lang="ts" context="module">
import { writable } from "svelte/store";

// returns a store that:
// starts out false
// becomes true when the async function f starts running
// becomes false when f resolves (or rejects)
export function activityStore<T>(f: (t: T) => Promise<any>) {
  const store = writable(false);
  async function run(data: T) {
    try {
      store.set(true);
      return await f(data);
    } finally {
      store.set(false);
    }
  }
  return { ...store, run };
}
</script>

<script lang="ts">
export let active = false;
</script>

<span class="loader" class:active={active} />

<style lang="scss">
.loader {
  width: 1em;
  height: 1em;
  border: 0.2em solid var(--links);
  border-radius: 50%;
  display: inline-block;
  box-sizing: border-box;
  &.active {
    border-bottom-color: transparent; // 3/4 border solid, 1/4 transparent
    animation: rotation 1s linear infinite;
  }
}

@keyframes rotation {
  0% {
    transform: rotate(0deg);
  }
  100% {
    transform: rotate(360deg);
  }
}
</style>


Path: D:\Modible\Software\pocketbase-sveltekit-starter\sk\src\lib\components\Tab.svelte
Contents:
<script lang="ts">
export let key: string | number;
import { getContext } from "svelte";
import type { Writable } from "svelte/store";
const store: Writable<string | number> = getContext("activeTab");
</script>

<button
  type="button"
  class="title"
  on:click={() => ($store = key)}
  class:active={$store === key}
>
  <slot />
</button>

<style>
</style>


Path: D:\Modible\Software\pocketbase-sveltekit-starter\sk\src\lib\components\TabContent.svelte
Contents:
<script lang="ts">
export let key: string | number;
import { getContext } from "svelte";
import type { Writable } from "svelte/store";
const store: Writable<string | number> = getContext("activeTab");
</script>

{#if $store === key}
  <slot />
{/if}


Path: D:\Modible\Software\pocketbase-sveltekit-starter\sk\src\lib\components\TabGroup.svelte
Contents:
<script lang="ts">
export let active: string | number = 0;
import { writable } from "svelte/store";
import type { Writable } from "svelte/store";
import { setContext } from "svelte";
const store: Writable<string | number> = writable(active);
setContext("activeTab", store);
</script>

<div class="tabs">
  <slot name="tabs" />
</div>

<div class="tab-content">
  <slot />
</div>

<style>
.tabs {
  border-bottom: 2px solid var(--tab-color-active-bg, white);
}
.tab-content {
  padding: 1em 0;
}
</style>


Path: D:\Modible\Software\pocketbase-sveltekit-starter\sk\src\lib\components\TagEditor.svelte
Contents:
<script lang="ts">
    import TagGroup from "$lib/components/TagGroup.svelte";
  import type { PostsResponse } from "$lib/pocketbase/generated-types";
  import { client } from "$lib/pocketbase";
  import { onMount } from 'svelte';
  
    export let post: PostsResponse;
    let tags: string[] = [];
  let tagInput: string = '';

  onMount(async () => {
    await loadTags();
    tagInput = tags.join(', ');
  });

  async function loadTags() {
      if (post.expand?.tags) {
        tags = post.expand.tags.map((tag: { title: any; }) => tag.title);
      } else {
        const postsTagsResponse = await client.collection("postsTags").getList(1, 50, {
          filter: `posts = "${post.id}"`,
        });
        const tagIds = postsTagsResponse.items.map((postTag) => postTag.tags);
        const loadedTags = await Promise.all(tagIds.map((tagId) => client.collection("tags").getOne(tagId)));
        tags = loadedTags.map((tag) => tag.title);
      }
    }
  
    $: {
      if (post) {
        loadTags();
      }
    }

    function handleInput(event: Event) {
    const input = (event.target as HTMLInputElement).value;
    tagInput = input;
    tags = input.split(',').map(tag => tag.trim()).filter(tag => tag);
  }

  $: {
    if (post) {
      loadTags();
    }
  }
</script>

<div class="mt-4">
  <input type="text" bind:value={tagInput} on:input={handleInput} class="input input-bordered w-full" placeholder="Enter tags separated by commas" />
</div>

<TagGroup {tags} />

Path: D:\Modible\Software\pocketbase-sveltekit-starter\sk\src\lib\components\TagGroup.svelte
Contents:
<script lang="ts">
    import { client } from "$lib/pocketbase";
    import type { PostsResponse, PostsRecord } from "$lib/pocketbase/generated-types";
    export let post: PostsResponse;
  
    let tags: string[] = [];
  
    async function loadTags() {
      if (post.expand?.tags) {
        tags = post.expand.tags.map((tag: { title: any; }) => tag.title);
      } else {
        const postsTagsResponse = await client.collection("postsTags").getList(1, 50, {
          filter: `posts = "${post.id}"`,
        });

        const tagIds = postsTagsResponse.items.map((postTag) => postTag.tags);
        const loadedTags = await Promise.all(tagIds.map((tagId) => client.collection("tags").getOne(tagId)));
        tags = loadedTags.map((tag) => tag.title);
      }
    }
  
    $: {
      if (post) {
        loadTags();
      }
    }
  </script>
  
  {#if tags.length > 0}
    <div class="mt-4 flex flex-wrap gap-2">
      {#each tags as tag}
        <a href={`/tags/${tag}`} class="badge badge-accent badge-outline p-2">
          {tag}
        </a>
      {/each}
    </div>
  {:else}
    <div class="badge badge-accent badge-outline">No tags</div>
  {/if}

Path: D:\Modible\Software\pocketbase-sveltekit-starter\sk\src\lib\components\ThemeSwitch.svelte
Contents:
<script>
  import { onMount } from "svelte";
  import { themes } from "$lib/utils/themes";

  let currentTheme = "light";
  /**
     * @type {HTMLDialogElement}
     */
  let modal;

  /**
     * @param {string} themeId
     */
  function changeTheme(themeId) {
    const theme = themes.find((t) => t.id === themeId);
    if (theme) {
      document.documentElement.setAttribute("data-theme", theme.id);
      currentTheme = theme.id;
      localStorage.setItem("theme", theme.id);
      modal.close();
    }
  }

  onMount(() => {
    const savedTheme = localStorage.getItem("theme");
    if (savedTheme && themes.some((t) => t.id === savedTheme)) {
      changeTheme(savedTheme);
    }
  });
</script>

<button class="btn btn-ghost m-1" on:click={() => modal.showModal()}>
  Theme
</button>

<dialog bind:this={modal} class="modal" id="modal">
  <div class="modal-box w-11/12 max-w-5xl">
    <h3 class="text-lg font-bold">Select a Theme</h3>
    <div class="grid grid-cols-1 gap-4 py-4 md:grid-cols-2 lg:grid-cols-3">
      {#each themes as theme (theme.id)}
        <button
          class="border-base-content/20 hover:border-base-content/40 cursor-pointer overflow-hidden rounded-lg border outline outline-2 outline-offset-2 outline-transparent"
          data-set-theme={theme.id}
          data-act-class="!outline-base-content"
          on:click={() => changeTheme(theme.id)}
        >
          <div data-theme={theme.id} class="bg-base-100 text-base-content w-full font-sans">
            <div class="grid grid-cols-5 grid-rows-3">
              <div class="bg-base-200 col-start-1 row-span-2 row-start-1"></div>
              <div class="bg-base-300 col-start-1 row-start-3"></div>
              <div class="bg-base-100 col-span-4 col-start-2 row-span-3 row-start-1 flex flex-col gap-1 p-2">
                <div class="font-bold">{theme.name}</div>
                <div class="flex flex-wrap gap-1">
                  <div class="bg-primary flex aspect-square w-5 items-center justify-center rounded lg:w-6">
                    <div class="text-primary-content text-sm font-bold">A</div>
                  </div>
                  <div class="bg-secondary flex aspect-square w-5 items-center justify-center rounded lg:w-6">
                    <div class="text-secondary-content text-sm font-bold">A</div>
                  </div>
                  <div class="bg-accent flex aspect-square w-5 items-center justify-center rounded lg:w-6">
                    <div class="text-accent-content text-sm font-bold">A</div>
                  </div>
                  <div class="bg-neutral flex aspect-square w-5 items-center justify-center rounded lg:w-6">
                    <div class="text-neutral-content text-sm font-bold">A</div>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </button>
      {/each}
    </div>
  </div>
  <form method="dialog" class="modal-backdrop">
    <button>Close</button>
  </form>
</dialog>

Path: D:\Modible\Software\pocketbase-sveltekit-starter\sk\src\lib\pocketbase\generated-types.ts
Contents:
/**
* This file was @generated using pocketbase-typegen
*/

export enum Collections {
	Images = "images",
	Posts = "posts",
	Tags = "tags",
	Users = "users",
}

// Alias types for improved usability
export type IsoDateString = string
export type RecordIdString = string

// System fields
export type BaseSystemFields = {
	id: RecordIdString
	created: IsoDateString
	updated: IsoDateString
	collectionId: string
	collectionName: Collections
	expand?: { [key: string]: any }
}

export type AuthSystemFields = {
	email: string
	emailVisibility: boolean
	username: string
	verified: boolean
} & BaseSystemFields

// Record types for each collection

export type ImagesRecord = {
	file?: string
}

export type PostsRecord = {
	title: string
	slug: string
	body: string
	blogSummary?: string
	featuredImage?: RecordIdString
	prompt?: string
	userid?: RecordIdString
	tags?: RecordIdString[]
}

export type TagsRecord = {
	title: string
}

export type UsersRecord = {
	name?: string
	avatar?: string
}

// Response types include system fields and match responses from the PocketBase API
export type ImagesResponse = ImagesRecord & BaseSystemFields
export type PostsResponse = PostsRecord & BaseSystemFields
export type TagsResponse = TagsRecord & BaseSystemFields
export type UsersResponse = UsersRecord & AuthSystemFields

export type CollectionRecords = {
	images: ImagesRecord
	posts: PostsRecord
	tags: TagsRecord
	users: UsersRecord
}

Path: D:\Modible\Software\pocketbase-sveltekit-starter\sk\src\lib\pocketbase\ImgModal.svelte
Contents:
<script lang="ts">
import type { Record } from "pocketbase";
import { client } from ".";
import Dialog from "$lib/components/Dialog.svelte";

export let record: Record;
export let filename: string;
export let thumbOnly = false;
</script>

{#if record && filename}
  {#await client.getFileUrl(record, filename, { thumb: "100x100" }) then src}
    <Dialog>
      <img src={src} alt="todo" slot="trigger" class="thumbnail" />
      {#if !thumbOnly}
        {#await client.getFileUrl(record, filename) then src}
          <img src={src} alt="todo" />
        {/await}
      {/if}
    </Dialog>
  {/await}
{/if}

<style lang="scss">
.thumbnail {
  cursor: pointer;
  border-radius: 5px;
  box-shadow: //
    0 0 5px 0px black;
}
</style>


Path: D:\Modible\Software\pocketbase-sveltekit-starter\sk\src\lib\pocketbase\index.ts
Contents:
import PocketBase, {
  ListResult,
  Record as PBRecord,
  type AuthProviderInfo,
  RecordService,
} from "pocketbase";
import type { Admin } from "pocketbase";
import { readable, type Readable, type Subscriber } from "svelte/store";
import { browser } from "$app/environment";
import { base } from "$app/paths";
import { invalidateAll } from "$app/navigation";

export const client = new PocketBase(
  browser ? window.location.origin + "/" + base : undefined
);

export const authModel = readable<PBRecord | Admin | null>(
  null,
  function (set) {
    client.authStore.onChange((token, model) => {
      set(model);
      invalidateAll(); // re-run load functions for current page
    }, true);
  }
);

export async function login(
  email: string,
  password: string,
  register = false,
  rest: { [key: string]: any } = {}
) {
  if (register) {
    const user = { ...rest, email, password, confirmPassword: password };
    await client.collection("users").create(user);
  }
  await client.collection("users").authWithPassword(email, password);
}

export function logout() {
  client.authStore.clear();
}

/*
 * Save (create/update) a record (a plain object). Automatically converts to
 * FormData if needed.
 */
export async function save(collection: string, record: any, create = false) {
  // convert obj to FormData in case one of the fields is instanceof FileList
  const data = object2formdata(record);
  if (record.id && !create) {
    // "create" flag overrides update
    return await client.collection(collection).update(record.id, data);
  } else {
    return await client.collection(collection).create(data);
  }
}

export async function savePostWithTags(
  collection: string,
  record: any,
  create = false
) {
  // Separate tags from the main record data
  const { tags: tagsStr, ...postData } = record;
  const tags = tagsStr
    .split(",")
    .map((tag: string) => tag.trim())
    .filter((tag: any) => tag);

  // Save the post data first
  const postResult = await save(collection, postData, create);
  const postId = create ? postResult.id : record.id; // Assuming the ID is returned for new records

  // Now handle the tags
  await processTags(tags, postId);

  return postResult;
}

async function processTags(tags: string[], postId: string) {
  for (const tagName of tags) {
    let tagRecord = await findOrCreateTag(tagName);
    await linkTagToPost(tagRecord.id, postId);
  }
}

async function findOrCreateTag(tagName: string): Promise<PBRecord> {
  // Implement the logic to find a tag by name or create it if it doesn't exist
  // This is a placeholder function
  return new PBRecord();
}

async function linkTagToPost(tagId: string, postId: string) {
  // Implement the logic to create a record in the `taggings` collection linking the tag to the post
  // This is a placeholder function
}

// convert obj to FormData in case one of the fields is instanceof FileList
function object2formdata(obj: {}) {
  // check if any field's value is an instanceof FileList
  if (
    !Object.values(obj).some(
      (val) => val instanceof FileList || val instanceof File
    )
  ) {
    // if not, just return the original object
    return obj;
  }
  // otherwise, build FormData (multipart/form-data) from obj
  const fd = new FormData();
  for (const [key, val] of Object.entries(obj)) {
    if (val instanceof FileList) {
      for (const file of val) {
        fd.append(key, file);
      }
    } else if (val instanceof File) {
      // handle File before "object" so that it doesn't get serialized as JSON
      fd.append(key, val);
    } else if (Array.isArray(val)) {
      // for some reason, multipart/form-data wants arrays to be comma-separated strings
      fd.append(key, val.join(","));
    } else if (typeof val === "object") {
      fd.append(key, JSON.stringify(val));
    } else {
      fd.append(key, val as any);
    }
  }
  return fd;
}

export interface PageStore<T = any> extends Readable<ListResult<T>> {
  [x: string]: any;
  setPage(newpage: number): Promise<void>;
  next(): Promise<void>;
  prev(): Promise<void>;
}

export function watch<T>(
  idOrName: string,
  queryParams = {} as any,
  page = 1,
  perPage = 20,
  realtime = browser
): PageStore<T> {
  const collection = client.collection(idOrName);
  let result = new ListResult(page, perPage, 0, 0, [] as T[]);
  let set: Subscriber<ListResult<T>>;
  const store = readable<ListResult<T>>(result, (_set) => {
    set = _set;
    // fetch first page
    collection
      .getList(page, perPage, queryParams)
      .then((r) => set((result = r as ListResult<T>)));
    // watch for changes (only if you're in the browser)
    if (realtime)
      collection.subscribe("*", ({ action, record }) => {
        (async function (action: string) {
          // see https://github.com/pocketbase/pocketbase/discussions/505
          async function expand(expand: any, record: any) {
            return expand
              ? await collection.getOne(record.id, { expand })
              : record;
          }
          switch (action) {
            case "update":
              record = await expand(queryParams.expand, record);
              return result.items.map((item) =>
                (item as { id: string }).id === record.id ? record : item
              );
            case "create":
              record = await expand(queryParams.expand, record);
              const index = result.items.findIndex((item: any) => item.id === record.id);
              // replace existing if found, otherwise append
              if (index >= 0) {
                result.items[index] = record as T;
              } else {
                result.items.push(record as T);
              }
              // The 'else' block is not needed because the 'if' block above always returns
              // Append the new record to the result items array
              result.items.push(record as T);
              break; // Use 'break' to exit the switch case after adding the item
            case "delete":
              // Filter out the deleted record from the result items array
              result.items = result.items.filter((item) => (item as any).id !== record.id);
              break; // Use 'break' to exit the switch case after filtering the item
          }
          return result.items;
        })(action).then((items) =>
          set((result = { ...result, items } as ListResult<T>))
        );
      });
  });
  async function setPage(newpage: number) {
    const { page, totalPages, perPage } = result;
    if (page > 0 && page <= totalPages) {
      set((result = await collection.getList(newpage, perPage, queryParams)));
    }
  }
  return {
    ...store,
    setPage,
    async next() {
      setPage(result.page + 1);
    },
    async prev() {
      setPage(result.page - 1);
    },
  };
}

export async function providerLogin(
  provider: AuthProviderInfo,
  authCollection: RecordService
) {
  const authResponse = await authCollection.authWithOAuth2({
    provider: provider.name,
    createData: {
      // emailVisibility: true,
    },
  });
  // update user "record" if "meta" has info it doesn't have
  const { meta, record } = authResponse;
  let changes = {} as { [key: string]: any };
  if (!record.name && meta?.name) {
    changes.name = meta.name;
  }
  if (!record.avatar && meta?.avatarUrl) {
    const response = await fetch(meta.avatarUrl);
    if (response.ok) {
      const type = response.headers.get("content-type") ?? "image/jpeg";
      changes.avatar = new File([await response.blob()], "avatar", { type });
    }
  }
  if (Object.keys(changes).length) {
    authResponse.record = await save(authCollection.collectionIdOrName, {
      ...record,
      ...changes,
    });
  }
  return authResponse;
}


Path: D:\Modible\Software\pocketbase-sveltekit-starter\sk\src\lib\pocketbase\Paginator.svelte
Contents:
<script lang="ts">
import type { PageStore } from ".";

export let store: PageStore;
export let showIfSinglePage = false;
</script>

{#if showIfSinglePage || $store.totalPages > 1}
  <div class="paginator">
    <button
      type="button"
      on:click={() => store.prev()}
      disabled={$store.page <= 1}>&laquo;</button
    >
    <div>page {$store.page} of {$store.totalPages}</div>
    <button
      type="button"
      on:click={() => store.next()}
      disabled={$store.page >= $store.totalPages}>&raquo;</button
    >
  </div>
{/if}

<style lang="scss">
.paginator {
  display: flex;
  align-items: center;
  gap: 1rem;
  margin: auto;
}
</style>


Path: D:\Modible\Software\pocketbase-sveltekit-starter\sk\src\lib\pocketbase\pocketbase-types.ts
Contents:
/**
 * This file was @generated using pocketbase-typegen
 */

export enum Collections {
  Hooks = "hooks",
  Posts = "posts",
  Users = "users",
}

// Alias types for improved usability
export type IsoDateString = string;
export type RecordIdString = string;
export type HTMLString = string;

// System fields
export type BaseSystemFields<T = never> = {
  id: RecordIdString;
  created: IsoDateString;
  updated: IsoDateString;
  collectionId: string;
  collectionName: Collections;
  expand?: T;
};

export type AuthSystemFields<T = never> = {
  email: string;
  emailVisibility: boolean;
  username: string;
  verified: boolean;
} & BaseSystemFields<T>;

// Record types for each collection

export enum HooksEventOptions {
  "insert" = "insert",
  "update" = "update",
  "delete" = "delete",
}

export enum HooksActionTypeOptions {
  "command" = "command",
  "post" = "post",
}
export type HooksRecord = {
  collection: string;
  event: HooksEventOptions;
  action_type: HooksActionTypeOptions;
  action: string;
  action_params?: string;
  expands?: string;
  disabled?: boolean;
};

export type PostsRecord = {
  title: string;
  featuredImage?: string;
  body: string;
  slug: string;
  files?: string[];
  tags?: string;
  userid?: RecordIdString;
  prompt?: string;
  blogSummary?: string;
};

export type UsersRecord = {
  name?: string;
  avatar?: string;
};

// Response types include system fields and match responses from the PocketBase API
export type HooksResponse = HooksRecord & BaseSystemFields;
export type PostsResponse = PostsRecord & BaseSystemFields;
export type UsersResponse = UsersRecord & AuthSystemFields;

// Types containing all Records and Responses, useful for creating typing helper functions

export type CollectionRecords = {
  hooks: HooksRecord;
  posts: PostsRecord;
  users: UsersRecord;
};

export type CollectionResponses = {
  hooks: HooksResponse;
  posts: PostsResponse;
  users: UsersResponse;
};


Path: D:\Modible\Software\pocketbase-sveltekit-starter\sk\src\lib\pocketbase\ui.ts
Contents:
import { alerts } from "$lib/components/Alerts.svelte";

// wrapper to execute a pocketbase client request and generate alerts on failure
export async function alertOnFailure(request: () => void) {
  try {
    await request();
  } catch (e: any) {
    const {
      message,
      data: { data = {} },
    } = e;
    if (message) alerts.error(message);
    for (const key in data) {
      const { message } = data[key];
      if (message) alerts.error(`${key}: ${message}`);
    }
  }
}


Path: D:\Modible\Software\pocketbase-sveltekit-starter\sk\src\lib\utils\api.ts
Contents:
// src/lib/utils/api.ts
// Improved error handling and abstraction of API URL and parameters

import { env } from "$env/dynamic/public";
import { client } from "$lib/pocketbase";

const engineId = "stable-diffusion-v1-6";
const apiHost = import.meta.env.VITE_STABILITY_API_HOST;

const API_BASE_URL = import.meta.env.VITE_APP_BASE_URL;
const CHATGPT_KEY = import.meta.env.VITE_CHATGPT_API_KEY;
const SD_KEY = import.meta.env.VITE_STABILITY_API_KEY;
const CLAUDE_KEY = import.meta.env.VITE_ANTHROPIC_API_KEY;
const DALLE_KEY = import.meta.env.VITE_CHATGPT_API_KEY;

//validate that keys are present
if (!API_BASE_URL) {
  throw new Error("Missing APP_BASE_URL");
}
if (!CHATGPT_KEY) {
  throw new Error("Missing CHATGPT_API_KEY");
}
if (!SD_KEY) {
  throw new Error("Missing STABILITY_API_KEY");
}
if (!CLAUDE_KEY) {
  throw new Error("Missing ANTHROPIC_API_KEY");
}
if (!DALLE_KEY) {
  throw new Error("Missing DALLE_API_KEY");
}

export async function apiRequest<T>(
  endpoint: string,
  method: "GET" | "POST" = "GET",
  body: any = null
): Promise<T> {
  const headers = { "Content-Type": "application/json" };
  const config: RequestInit = { method, headers };

  if (body) {
    config.body = JSON.stringify(body);
  }

  try {
    const response = await fetch(`${API_BASE_URL}${endpoint}`, config);
    if (!response.ok) {
      // Assuming the response includes a JSON body with an error message
      const errorBody = await response.json();
      throw new Error(
        errorBody.message || `Request failed with status ${response.status}`
      );
    }
    return await response.json();
  } catch (error) {
    // Log the error to an error reporting service if you have one
    console.error("API Request failed:", error);
    throw error;
  }
}

export async function ensureTagsExist(tags: string[]): Promise<string[]> {
  const existingTags = await client.collection("tags").getFullList({
    filter: tags.map((tag) => `title = "${tag}"`).join(" || "),
  });

  const existingTagTitles = existingTags.map((tag) => tag.title);
  const newTagTitles = tags.filter((tag) => !existingTagTitles.includes(tag));

  const newTags = await Promise.all(
    newTagTitles.map((title) => client.collection("tags").create({ title }))
  );

  return [...existingTags, ...newTags].map((tag) => tag.id);
}

export async function getTagsForPost(slug: string): Promise<string> {
  try {
    console.log("Fetching tags for post", slug);
    const postsResponse = await client.collection("posts").getFirstListItem(`slug = "${slug}"`, {
      expand: "tags",
    });
    if (!postsResponse) {
      return "";
    }

    const tags = postsResponse.expand?.tags?.map((tag: { title: any; }) => tag.title) || [];
    console.log("Tags for post", slug, tags);
    return tags.join(", ");
  } catch (error) {
    console.error("Error fetching tags:", error);
    return "";
  }
}

export async function generateTextFromClaude(prompt: string): Promise<string> {
  try {
    console.log("Generating text from Claude", prompt);
    const response = await fetch("/api/proxy/anthropic", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify({
        human: prompt,
      }),
    });
    console.log("Response from Claude", response);
    
    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }

    const data = await response.json();
    return data.response;
  } catch (error) {
    console.error("Error:", error);
    throw error;
  }
}

export async function generateImageFromDalle(prompt: string): Promise<string> {
  try {
    const response = await fetch(
      "https://api.openai.com/v1/images/generations",
      {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          Authorization: `Bearer ${DALLE_KEY}`,
        },
        body: JSON.stringify({
          model: "image-alpha-001",
          prompt: prompt,
          num_images: 1,
          size: "512x512",
          response_format: "url",
        }),
      }
    );
    if (!response.ok) throw new Error("Failed to generate image from Dalle");

    const data = await response.json();
    return data.data[0].url;
  } catch (error) {
    console.error("Error:", error);
    throw error;
  }
}

export async function generateImageFromDreamStudio(
  prompt: string
): Promise<string> {
  try {
    const response = await fetch(
      `https://api.stability.ai/v1/generation/${engineId}/text-to-image`,
      {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          Authorization: `Bearer ${SD_KEY}`,
        },
        body: JSON.stringify({
          text_prompts: [{ text: prompt }],
          cfg_scale: 7,
          clip_guidance_preset: "FAST_BLUE",
          height: 512,
          width: 512,
          samples: 1,
          steps: 30,
        }),
      }
    );
    console.log("Response from DreamStudio", response);
    if (!response.ok)
      throw new Error("Failed to generate image from DreamStudio");
    const data = await response.json();
    return data.artifacts[0].base64;
  } catch (error) {
    console.error("Error:", error);
    throw error;
  }
}

export async function generateTextFromChatGPT(prompt: string): Promise<string> {
  try {
    const response = await fetch("https://api.openai.com/v1/chat/completions", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Authorization: `Bearer ${CHATGPT_KEY}`,
      },
      body: JSON.stringify({
        model: "gpt-3.5-turbo",
        messages: [{ role: "user", content: prompt }],
        max_tokens: 1024,
        n: 1,
        stop: null,
        temperature: 0.5,
        top_p: 0.5,
      }),
    });
    if (!response.ok) throw new Error("Failed to generate text from ChatGPT");
    const data = await response.json();
    return data.choices[0].message.content.trim();
  } catch (error) {
    console.error("Error:", error);
    throw error;
  }
}


Path: D:\Modible\Software\pocketbase-sveltekit-starter\sk\src\lib\utils\prompts.ts
Contents:
/* export const promptFormat = `Title: Idea Exploration and Brain Mapping

Description: This prompt is designed to take a single phrase, idea, or concept input and deeply explore it across various dimensions. It aims to generate a rich, interconnected map of thoughts, questions, possibilities, and related topics to serve as a creative or analytical reference.

Input Instructions:
- Clearly state the phrase, idea, or concept you wish to explore.
- Provide any specific context or constraints you want the exploration to adhere to, such as a particular field of interest (e.g., technology, philosophy, art), purpose (e.g., innovation, problem-solving, education), or any specific questions you're looking to answer.

Output Specifications:
1. **Initial Overview**: A brief summary of the core idea or concept, including its basic definition or understanding in common parlance or within specific domains if applicable.
2. **Exploratory Questions**: A list of open-ended questions that stem from the initial idea, designed to provoke thought, uncover underlying assumptions, or explore potential implications and applications.
3. **Possibilities and Scenarios**: Detailed descriptions of possible scenarios, applications, or manifestations of the idea in various contexts. This section should aim to broaden the horizon of the initial concept, suggesting innovative or unconventional perspectives.
4. **Related Topics and Ideas**: Identification of closely and peripherally related topics, ideas, or concepts that could enrich or be enriched by the initial idea. This may include cross-disciplinary links, opposing viewpoints, or complementary concepts.
5. **Resources for Further Exploration**: A curated list of suggested readings, resources, or activities that could deepen understanding or expand the exploration of the idea. This could include books, articles, podcasts, or interactive tools.

Example Input:
"Explore the concept of 'Artificial Intelligence' with a focus on its implications for creative industries, considering ethical considerations and future innovation opportunities."

Example Output:
1. **Initial Overview**: Artificial Intelligence (AI) refers to the simulation of human intelligence in machines...
2. **Exploratory Questions**: What are the ethical implications of AI in art creation? Can AI truly replicate the creative process of humans?...
3. **Possibilities and Scenarios**: In the realm of music production, AI could revolutionize...
4. **Related Topics and Ideas**: Machine Learning, Creativity, Ethical AI, Human-AI Collaboration...
5. **Resources for Further Exploration**: "Life 3.0" by Max Tegmark, TED Talks on AI and creativity...

Usage Note: This prompt format can be adapted and expanded based on the complexity of the idea or concept being explored and the depth of exploration desired. Use eleborate markdown and emojis to make the output more engaging and visually appealing.`;

export const titlePrompt =
  "Given the content and key insights of a blog post, distill its essence and main arguments into a concise, compelling title that captures the reader's attention and accurately reflects the post's themes and conclusions. The title should be clear, engaging, and informative, providing a strong indication of the post's content and value. Do not output the body or tags, ONLY the title. The title should be a single sentence and should not exceed 35 characters. It should not end with a period. The title should be written in title case, with all words capitalized except for articles, prepositions, and conjunctions. Do not use any format other than the one specified";

export const tagPrompt =
  "Please summarize the provided blog article, focusing on its main points and themes. Following your summary, identify and list 3-5 relevant tags that capture the essence of the article. These tags should be short, lowercase, single words, and separated by commas. Ensure the tags strictly adhere to this format: 'example1, example2, example3'. Do not include spaces between the commas and words, and do not use any format other than the one specified. Do not output the summary ONLY the tags.";

export const blogSummaryPrompt =
  "Please review the provided blog article thoroughly. After your review, compose a few sentences summary that encapsulates the main points and themes of the article. It should be between 40-80 words exactlyThis summary should be concise and engaging, designed to accompany the article's title on a Tailwind CSS card as a brief overview. Ensure the summary captures the essence of the blog, highlighting its value or unique perspective to intrigue and inform potential readers.Use eleborate markdown and emojis to make the output more engaging and visually appealing. Do not output the body or tags, ONLY the summary. Do not use any format other than the one specified.";

export const imagePrompt =
  "Please review the provided text and generate a prompt for a slick minimal, modern image that captures the essence of the text.";

export const introPrompt = `You are a creative and unique idea generator. When given a phrase or thought, your task is to rephrase it into 5 distinct ideas, each from a different perspective:

  1. Optimistic: Always sees the glass as half full and believes in the best possible outcome.
  2. Pessimistic: Tends to see the downside in every situation and prepares for the worst.
  3. Realistic: Looks at the facts and figures to make practical and logical decisions.
  4. Creative: Thinks outside the box and approaches problems with a fresh perspective.
  5. Analytical: Breaks down problems into smaller parts to understand the underlying issues.
  
  Respond by providing five separate prompts based on how someone with each perspective would interpret the original idea. Generate alternative prompts that further explain the concept from each viewpoint.
  
  Format your response as follows:
  Optimistic: [Optimistic interpretation]
  Pessimistic: [Pessimistic interpretation]
  Realistic: [Realistic interpretation]
  Creative: [Creative interpretation]
  Analytical: [Analytical interpretation]
  
  Do not use hashtags or any other separators between the ideas. Simply start each line with the perspective name followed by a colon and the corresponding interpretation.
  
  Here is the original thought or phrase to interpret:`;
 */

  export const promptFormat = `Title: Comprehensive Idea Exploration and Mind Mapping

Description: This prompt is designed to take a single phrase, idea, or concept as input and explore it in-depth across various dimensions. The goal is to generate a comprehensive, interconnected map of thoughts, questions, possibilities, and related topics to serve as a rich creative or analytical reference.

Input Instructions:
- Clearly state the phrase, idea, or concept you wish to explore.
- Provide any specific context or constraints you want the exploration to adhere to, such as a particular field of interest (e.g., technology, philosophy, art), purpose (e.g., innovation, problem-solving, education), or any specific questions you're looking to answer.
- If applicable, mention any additional perspectives or dimensions you'd like the exploration to cover.

Output Specifications:
1. **Initial Overview**: A concise summary of the core idea or concept, including its basic definition, common understanding, and any relevant domain-specific interpretations.
2. **Exploratory Questions**: A comprehensive list of thought-provoking, open-ended questions that arise from the initial idea. These questions should uncover underlying assumptions, explore potential implications, and delve into practical applications.
3. **Possibilities and Scenarios**: Detailed descriptions of diverse scenarios, applications, or manifestations of the idea across various contexts. This section should expand the horizon of the initial concept, offering innovative, unconventional, and cross-disciplinary perspectives.
4. **Related Topics and Ideas**: Identification of a wide range of closely and peripherally related topics, ideas, or concepts that could enrich or be enriched by the initial idea. This may include interdisciplinary connections, contrasting viewpoints, or complementary concepts.
5. **Actionable Insights**: Derive practical insights, recommendations, or action points based on the exploration of the idea. These should be concrete, applicable suggestions that readers can implement or further investigate.
6. **Resources for Further Exploration**: A carefully curated list of recommended readings, resources, or activities to deepen understanding and expand the exploration of the idea. This could include books, articles, podcasts, videos, courses, or interactive tools.

Example Input:
"Explore the concept of 'Artificial Intelligence' with a focus on its implications for creative industries, considering ethical considerations, future innovation opportunities, and its potential impact on the workforce."

Example Output:
1. **Initial Overview**: Artificial Intelligence (AI) refers to the simulation of human intelligence in machines... 🤖
2. **Exploratory Questions**: 
   - What are the ethical implications of AI in creative processes? 🎨🔍
   - Can AI truly replicate the emotional depth and nuance of human creativity? 🧠❓
   - How might AI augment or enhance human creativity rather than replace it? 🤝💡
   ...
3. **Possibilities and Scenarios**: 
   - In the realm of music production, AI could revolutionize the composition process by... 🎵🎹
   - AI-powered tools could assist writers in generating unique story ideas, plots, and characters... 📝✨
   ...
4. **Related Topics and Ideas**:
   - Machine Learning 🧠📊
   - Computational Creativity 🎨💻
   - Ethical AI 🤖❤️
   - Human-AI Collaboration 👥🤝🤖
   ...
5. **Actionable Insights**:
   - Creative professionals should proactively learn about AI technologies to harness their potential... 📖💡
   - Organizations must develop ethical guidelines and frameworks for the use of AI in creative industries... 📜✅
   ...
6. **Resources for Further Exploration**:
   - Book: "The Creativity Code" by Marcus du Sautoy 📚
   - TED Talk: "How AI can enhance our memory, work and social lives" by Tom Gruber 🎥
   - Online Course: "Creative Applications of Deep Learning with TensorFlow" on Kadenze 🎓
   ...

Usage Note: This prompt format can be adapted and expanded based on the complexity of the idea or concept being explored and the depth of exploration desired. Feel free to customize the output specifications and example to suit your specific needs. Only export blog as if it were cut/paste into a magazine. Do not include any intro text about the output, just respond with the blog. This is the user's inspiration: `; //Use rich markdown formatting and relevant emojis to make the output visually engaging and easy to navigate

export const titlePrompt = `Craft an SEO-Optimized Title for Your Blog Post: Detailed Instructions

Accurately Reflect Content: Your title should encapsulate the blog's primary themes, insights, and conclusions, integrating relevant keywords for SEO.
Clear and Engaging: Construct a title that is both informative and enticing, offering a glimpse into the post's value and compelling readers to click.
Length and Format: Aim for a concise title of 5-7 words, keeping within 50-60 characters to ensure full visibility in search engine results. This aligns with SEO best practices for HTML page titles, maximizing impact and search rankings.
Title Case and Punctuation: Apply title case capitalization, with all principal words capitalized except for articles, prepositions, and conjunctions. Avoid ending the title with punctuation to maintain clarity and focus.
Plain Text: Present the title in plain text format, suitable for inclusion in the HTML <title> tag, enhancing both SEO and user click-through rates.
Example Scenario:
"Delve into the advantages and challenges of remote work, including strategies for sustaining productivity, balancing work-life dynamics, and ensuring effective team collaboration in a digital workspace."

Optimized Title Example:
"Remote Work Success: 5 Essential Strategies"

When formulating your blog article's title, follow these guidelines closely to craft a single, SEO-optimized title. Ensure it meets the specified length and character count for optimal online visibility and engagement, without adding extra text or comments.`;

export const tagPrompt = `Please analyze the provided blog article and generate relevant tags based on its main points and themes. The tags should:

- Consist of 5 concise, lowercase, single-word tags, can be 2 or 3 words just joined together) that capture the essence of the article
- They shoud be separated by commas, without any spaces between the commas and words
- Cover key topics, concepts, or categories mentioned in the article
- Help readers quickly identify the article's main focus areas and improve searchability
- Only use alphabets, no special characters or numbers
- Be output as plain text, strictly adhering to the specified format: 'tag1,tag2,tag3,tag4,tag5'

Example Input:
"This article discusses the importance of mindfulness in reducing stress and improving overall well-being. It explores various mindfulness techniques, such as meditation, deep breathing, and yoga, and provides practical tips for incorporating these practices into daily life."

Example Output:
mindfulness,stress,well-being,meditation,breathing,yoga,tips

Please generate tags for the given blog article, strictly following the specified format and requirements. Output only the tags, without any additional text or formatting. This is the blog article: `;

export const blogSummaryPrompt = `Please compose a concise and engaging summary for the provided blog article, designed to accompany the article's title on a Tailwind CSS card. The summary should:

- Encapsulate the main points, themes, and value proposition of the article in 50-100 words
- Be clear, informative, and captivating, encouraging readers to click through and read the full article
- Highlight the article's unique perspective, actionable insights, or key takeaways
- Use a mix of simple and compound sentences to create a flowing, easy-to-read narrative
- Incorporate relevant emojis and markdown formatting to make the summary visually appealing and engaging
- Be output as a single paragraph of plain text, without any additional content or formatting

Example Input:
"This article delves into the world of productivity hacks, offering practical tips and strategies to help readers maximize their time and efficiency. From prioritizing tasks using the Eisenhower Matrix to leveraging the power of time-blocking and pomodoro techniques, this post provides a comprehensive guide to boosting productivity in both personal and professional life."

Example Output:
🚀 Unlock the secrets to peak productivity with this ultimate guide! 🔓📈 Discover proven techniques like the Eisenhower Matrix, time-blocking, and pomodoro to maximize your time and efficiency. 📅⏰ Whether you're looking to crush your personal goals or excel in your professional life, this article offers practical, actionable insights to help you master the art of productivity. 💪📚 Get ready to take your performance to the next level! 🎯🌟

Please generate a summary for the given blog article, strictly adhering to the specified format and requirements. Output only the summary, without any additional text or formatting. This is the blog article: `;

export const imagePrompt = `Enhanced Image Prompt Generation Guidelines:

"Analyze the provided text to create a comprehensive prompt for designing an image that not only encapsulates the text's core message but also adheres to a specific aesthetic directive. The crafted image prompt should:

Concisely depict a scene or concept that aligns with the main ideas or themes presented in the text, ensuring the visual representation is both impactful and relevant.
Clearly define a minimalist, modern style, emphasizing a sleek design with a 2-3 color monotone palette to ensure visual consistency and cohesion across images.
Detail the composition, including any critical elements or symbols that should be featured, to reinforce the text's message through visual means.
Direct the mood, emotion, or atmosphere to reflect the text's tone, using minimalistic design principles to evoke the intended feelings in the audience.
Utilize natural language to offer clear, precise instructions tailored for an artist or designer, encapsulating the request in 3-5 descriptive sentences.
The description must be delivered as plain text, focused solely on the image prompt without additional content or formatting.

Make sure to NOT include faces or hands in the image - call this out specifically!

Example Input:
'This article explores the concept of minimalism as a lifestyle choice, discussing its benefits for mental clarity, financial freedom, and environmental sustainability. It offers practical tips for decluttering, simplifying one's life, and finding contentment with less.'

Example Output:
'Design a sleek, minimalistic image that reflects the essence of adopting a minimalist lifestyle for mental clarity and sustainable living. The scene should be set in a modern, sparsely decorated interior with vast negative space, featuring 2-3 colors such as white, soft gray, and a hint of green from a solitary plant. This space should embody tranquility, simplicity, and the elegance of minimalism, with just a few items of furniture that highlight functionality and aesthetic appeal. Aim to capture a mood of calmness and introspection, encouraging viewers to envisage a life of fewer possessions but greater purpose.'

This is the users text:`;


export const introPrompt = `You are an innovative thought generator, capable of interpreting a given phrase or idea from five distinct perspectives. When presented with a concept, your task is to rephrase it into five unique ideas, each embodying a different viewpoint:

1. 🌞 Optimistic: Consistently sees the bright side and envisions the most favorable outcomes.
2. 🌧️ Pessimistic: Tends to focus on the negative aspects and anticipates potential drawbacks.
3. 🧐 Realistic: Assesses situations objectively, basing decisions on facts and practicality.
4. 🎨 Creative: Approaches challenges with originality, thinking innovatively to generate novel ideas.
5. 🔍 Analytical: Methodically deconstructs issues to identify underlying causes and patterns.

For each perspective, generate a thought-provoking interpretation of the original concept, offering a deeper understanding of the idea through the lens of that particular mindset.

Please format your response as follows, using only plain text without any additional separators or formatting (seperate each interpretation with a new line):

Optimistic: [Optimistic interpretation]
Pessimistic: [Pessimistic interpretation] 
Realistic: [Realistic interpretation]
Creative: [Creative interpretation]
Analytical: [Analytical interpretation]

Example Input:
"The impact of social media on personal relationships and communication"

Example Output:
Optimistic: Social media has the power to strengthen connections, fostering deeper relationships and enabling people to stay in touch across vast distances.
Pessimistic: Social media is eroding the quality of personal interactions, leading to superficial relationships and a growing sense of isolation and disconnection.
Realistic: Social media is a tool that can facilitate or hinder personal relationships, depending on how it is used and the individual's ability to balance online and offline communication.
Creative: Social media is transforming the landscape of human interaction, giving rise to new forms of self-expression, collaboration, and community-building that transcend traditional boundaries.
Analytical: The impact of social media on personal relationships is complex and multifaceted, influenced by factors such as platform design, user behavior, and societal norms, requiring ongoing research and analysis to fully understand its implications.

ONLY RESPOND WITH THE FIVE INTERPRETATIONS, NO ADDITIONAL TEXT OR FORMATTING.

Please provide your five perspectives on the following concept:`;

Path: D:\Modible\Software\pocketbase-sveltekit-starter\sk\src\lib\utils\themes.ts
Contents:
export const themes = [
    {
      id: "light",
      name: "Light",
      backgroundColor: "#ffffff",
      textColor: "#000000",
      primaryColor: "#f0f0f0",
      secondaryColor: "#e0e0e0",
      accentColor: "#d0d0d0"
    },
    {
      id: "dark",
      name: "Dark",
      backgroundColor: "#000000",
      textColor: "#ffffff",
      primaryColor: "#111111",
      secondaryColor: "#222222",
      accentColor: "#333333"
    },
    {
      id: "cupcake",
      name: "Cupcake",
      backgroundColor: "#f8e5e5",
      textColor: "#8b5e34",
      primaryColor: "#f4c7c7",
      secondaryColor: "#e6b8b8",
      accentColor: "#d9a3a3"
    },
    {
      id: "bumblebee",
      name: "Bumblebee",
      backgroundColor: "#fef3c7",
      textColor: "#78350f",
      primaryColor: "#fde68a",
      secondaryColor: "#fcd34d",
      accentColor: "#fbbf24"
    },
    {
      id: "emerald",
      name: "Emerald",
      backgroundColor: "#ecfdf5",
      textColor: "#064e3b",
      primaryColor: "#d1fae5",
      secondaryColor: "#a7f3d0",
      accentColor: "#6ee7b7"
    },
    {
      id: "corporate",
      name: "Corporate",
      backgroundColor: "#ffffff",
      textColor: "#1f2937",
      primaryColor: "#e5e7eb",
      secondaryColor: "#d1d5db",
      accentColor: "#9ca3af"
    },
    {
      id: "synthwave",
      name: "Synthwave",
      backgroundColor: "#2b213a",
      textColor: "#e2e2e2",
      primaryColor: "#302b63",
      secondaryColor: "#4a00e0",
      accentColor: "#8e2de2"
    },
    {
      id: "retro",
      name: "Retro",
      backgroundColor: "#fffbeb",
      textColor: "#3f2a22",
      primaryColor: "#fde68a",
      secondaryColor: "#fcd34d",
      accentColor: "#fbbf24"
    },
    {
      id: "cyberpunk",
      name: "Cyberpunk",
      backgroundColor: "#0f0f0f",
      textColor: "#f1f1f1",
      primaryColor: "#ff7a18",
      secondaryColor: "#fe640b",
      accentColor: "#fd7e14"
    },
    {
      id: "valentine",
      name: "Valentine",
      backgroundColor: "#fce7f3",
      textColor: "#831843",
      primaryColor: "#fbcfe8",
      secondaryColor: "#f9a8d4",
      accentColor: "#f472b6"
    },
    {
      id: "halloween",
      name: "Halloween",
      backgroundColor: "#0f172a",
      textColor: "#f8fafc",
      primaryColor: "#1e293b",
      secondaryColor: "#334155",
      accentColor: "#4b5563"
    },
    {
      id: "garden",
      name: "Garden",
      backgroundColor: "#ecfccb",
      textColor: "#365314",
      primaryColor: "#d9f99d",
      secondaryColor: "#bef264",
      accentColor: "#a3e635"
    },
    {
      id: "forest",
      name: "Forest",
      backgroundColor: "#1a202c",
      textColor: "#f5f5f4",
      primaryColor: "#2d3748",
      secondaryColor: "#4a5568",
      accentColor: "#718096"
    },
    {
      id: "aqua",
      name: "Aqua",
      backgroundColor: "#e6fffa",
      textColor: "#0d5553",
      primaryColor: "#b2f5ea",
      secondaryColor: "#81e6d9",
      accentColor: "#4fd1c5"
    },
    {
      id: "lofi",
      name: "Lo-Fi",
      backgroundColor: "#f9fafb",
      textColor: "#1f2937",
      primaryColor: "#e5e7eb",
      secondaryColor: "#d1d5db",
      accentColor: "#9ca3af"
    },
    {
      id: "pastel",
      name: "Pastel",
      backgroundColor: "#fdf2f8",
      textColor: "#701a75",
      primaryColor: "#f5d0fe",
      secondaryColor: "#f0abfc",
      accentColor: "#e879f9"
    },
    {
      id: "fantasy",
      name: "Fantasy",
      backgroundColor: "#f0fdfa",
      textColor: "#075985",
      primaryColor: "#ccfbf1",
      secondaryColor: "#99f6e4",
      accentColor: "#5eead4"
    },
    {
      id: "wireframe",
      name: "Wireframe",
      backgroundColor: "#f8f8f8",
      textColor: "#333333",
      primaryColor: "#e2e2e2",
      secondaryColor: "#cccccc",
      accentColor: "#b3b3b3"
    },
    {
      id: "black",
      name: "Black",
      backgroundColor: "#000000",
      textColor: "#ffffff",
      primaryColor: "#111111",
      secondaryColor: "#222222",
      accentColor: "#333333"
    },
    {
      id: "luxury",
      name: "Luxury",
      backgroundColor: "#1a1a1a",
      textColor: "#fafafa",
      primaryColor: "#2e2e2e",
      secondaryColor: "#3b3b3b",
      accentColor: "#525252"
    },
    {
      id: "dracula",
      name: "Dracula",
      backgroundColor: "#282a36",
      textColor: "#f8f8f2",
      primaryColor: "#44475a",
      secondaryColor: "#6272a4",
      accentColor: "#bd93f9"
    },
    {
      id: "cmyk",
      name: "CMYK",
      backgroundColor: "#0f172a",
      textColor: "#f1f5f9",
      primaryColor: "#1e293b",
      secondaryColor: "#334155",
      accentColor: "#4b5563"
    },
    {
      id: "autumn",
      name: "Autumn",
      backgroundColor: "#fef2f2",
      textColor: "#7f1d1d",
      primaryColor: "#fecaca",
      secondaryColor: "#fca5a5",
      accentColor: "#f87171"
    },
    {
      id: "business",
      name: "Business",
      backgroundColor: "#1e293b",
      textColor: "#f1f5f9",
      primaryColor: "#334155",
      secondaryColor: "#475569",
      accentColor: "#64748b"
    },
    {
      id: "acid",
      name: "Acid",
      backgroundColor: "#f0fdf4",
      textColor: "#166534",
      primaryColor: "#dcfce7",
      secondaryColor: "#bbf7d0",
      accentColor: "#86efac"
    },
    {
      id: "lemonade",
      name: "Lemonade",
      backgroundColor: "#fff7ed",
      textColor: "#7c2d12",
      primaryColor: "#ffedd5",
      secondaryColor: "#fed7aa",
      accentColor: "#fdba74"
    },
    {
      id: "night",
      name: "Night",
      backgroundColor: "#0f172a",
      textColor: "#f1f5f9",
      primaryColor: "#1e293b",
      secondaryColor: "#334155",
      accentColor: "#4b5563"
    },
    {
      id: "coffee",
      name: "Coffee",
      backgroundColor: "#1c1917",
      textColor: "#fafaf9",
      primaryColor: "#292524",
      secondaryColor: "#3f3f46",
      accentColor: "#52525b"
    },
    {
      id: "winter",
      name: "Winter",
      backgroundColor: "#f8fafc",
      textColor: "#0f172a",
      primaryColor: "#e2e8f0",
      secondaryColor: "#cbd5e1",
      accentColor: "#94a3b8"
    },
    {
      id: "dim",
      name: "Dim",
      backgroundColor: "#1a1c1e",
      textColor: "#e4e4e7",
      primaryColor: "#2b2b2b",
      secondaryColor: "#3f3f46",
      accentColor: "#52525b"
    },
    {
      id: "nord",
      name: "Nord",
      backgroundColor: "#f8fafc",
      textColor: "#0f172a",
      primaryColor: "#e2e8f0",
      secondaryColor: "#cbd5e1",
      accentColor: "#94a3b8"
    },
    {
      id: "sunset",
      name: "Sunset",
      backgroundColor: "#f8f5e4",
      textColor: "#1c1917",
      primaryColor: "#fed7aa",
      secondaryColor: "#fed7aa",
      accentColor: "#fdba74"
    }
  ];

Path: D:\Modible\Software\pocketbase-sveltekit-starter\sk\src\routes\+layout.svelte
Contents:
<script lang="ts" context="module">
import { beforeNavigate } from "$app/navigation";
import { metadata } from "$lib/app/stores";
import { site } from "$lib/config";
import PocketBase from "pocketbase";

// Initialize PocketBase client
const pb = new PocketBase(`$(import.meta.env.VITE_APP_BASE_URL)`);
</script>

<script lang="ts">
import "../app.scss";
import Alerts from "$lib/components/Alerts.svelte";
import Nav from "$lib/components/Nav.svelte";

$: title = $metadata.title ? $metadata.title + " | " + site.name : site.name;
$: description = $metadata.description ?? site.description;
$: headline = $metadata.headline ?? $metadata.title;

// Reset metadata on navigation so that the new page inherits nothing from the old page
beforeNavigate(() => {
  $metadata = {};
});
</script>

<svelte:head>
  <title>{title}</title>
  <meta name="description" content={description} />
</svelte:head>

<div class="flex min-h-screen flex-col">
  <header>
    <Nav />
  </header>

  <main class="flex-grow">
    <div class="pt-4">
      <div class="mx-auto max-w-7xl px-4 sm:px-6 lg:px-8">
        <div class="mx-auto max-w-2xl text-center">
          {#if headline}
            <h1
              class="text-primary text-3xl font-bold tracking-tight sm:text-4xl"
            >
              {headline}
            </h1>
          {/if}
          <Alerts />
        </div>
        <slot />
      </div>
    </div>
  </main>

  <footer class="py-4">
    <div class="mx-auto max-w-7xl px-4 text-center sm:px-6 lg:px-8">
      <p class="text-base-content text-sm">
        &copy; {new Date().getFullYear()}
        {site.name}. All rights reserved.
      </p>
    </div>
  </footer>
</div>


Path: D:\Modible\Software\pocketbase-sveltekit-starter\sk\src\routes\+layout.ts
Contents:
import type { LayoutLoad } from "./$types";
import { alerts } from "$lib/components/Alerts.svelte";

// turn off SSR - we're JAMstack here
export const ssr = false;

// Prerendering turned off. Turn it on if you know what you're doing.
export const prerender = false;

// trailing slashes make relative paths much easier
export const trailingSlash = "always";

export const load: LayoutLoad = async ({ fetch }) => {
  const response = await fetch("/_/");
  if (response.redirected) {
    alerts.add({
      message: 'Please visit <a href="/_/">/_ </a> to finalize installation of PocketBase',
      type: "error",
      html: true,
    });
  }
  return {}; // Return an empty object or an object with necessary properties
};

Path: D:\Modible\Software\pocketbase-sveltekit-starter\sk\src\routes\+page.svelte
Contents:
<script lang="ts">
import { metadata } from "$lib/app/stores";
import { fade, fly } from "svelte/transition";
import Particles from "svelte-particles";
import { loadSlim } from "tsparticles-slim";

//$metadata.title =
//  "mind.ai - Transform Your Thoughts into a Flourishing Mind Garden";
$metadata.description =
  "Discover how mind.ai empowers you to nurture, organize, and grow your ideas into something beautiful through AI-powered journaling and the Mind Gardens methodology.";

let particlesConfig = {
  particles: {
    color: {
      value: "#ffffff",
    },
    links: {
      enable: true,
      color: "#ffffff",
    },
    move: {
      enable: true,
    },
    number: {
      value: 20,
    },
    size: {
      value: 3,
    },
  },
  interactivity: {
    events: {
      onhover: {
        enable: true,
        mode: "repulse",
      },
    },
  },
};

let onParticlesLoaded = (event: CustomEvent<{ particles?: any }>) => {
  const particlesContainer = event.detail.particles;
  // you can use particlesContainer to call all the Container class
  // (from the core library) methods like play, pause, refresh, start, stop
};

let particlesInit = async (engine: any) => {
  await loadSlim(engine);
};
</script>

<svelte:head>
  <title>{$metadata.title}</title>
  <meta name="description" content={$metadata.description} />
</svelte:head>


<!-- Particles Background -->
<Particles
id="tsparticles"
options={particlesConfig}
on:particlesLoaded={onParticlesLoaded}
particlesInit={particlesInit}
/>

<!-- Hero Section -->
<div
  class="hero min-h-screen"
  style="background-image: url(img/treeBrain.png);"
>
  <div class="hero-overlay bg-opacity-60"></div>
  <div class="hero-content text-neutral-content text-center">
    <div class="max-w-md">
      <h1 class="mb-5 text-5xl font-bold">
        Transform Your Thoughts into a Flourishing Mind Garden with AI
      </h1>
      <p class="mb-5">
        Discover how mind.ai empowers you to nurture, organize, and grow your
        ideas into something beautiful.
      </p>
      <button class="btn btn-primary">Plant Your First Thought Today</button>
    </div>
  </div>
</div>

<!-- Introduction to Mind Gardens Methodology -->
<div class="bg-base-100 py-16">
  <div class="container mx-auto px-4 sm:px-6 lg:px-8">
    <div class="mb-12 text-center" transition:fade={{ duration: 500 }}>
      <h2 class="mb-4 text-4xl font-bold">Cultivate Your Mental Ecosystem</h2>
      <p class="text-xl">
        In the Mind Gardens methodology, each thought or idea is a seed that can
        grow into insights and creations. mind.ai facilitates this growth
        through AI-powered journaling, helping you nurture your mental
        ecosystem.
      </p>
    </div>
    <div class="flex justify-center">
      <img
        src="img/mindgarden.png"
        alt="Mind Garden Infographic"
        class="w-full max-w-screen-md rounded-xl object-cover shadow-xl"
        transition:fly={{ y: 20, duration: 500 }}
      />
    </div>
  </div>
</div>

<!-- Features and Benefits -->
<div class="bg-base-200 py-16" id="features">
  <div class="container mx-auto px-4 sm:px-6 lg:px-8">
    <div class="grid grid-cols-1 gap-8 md:grid-cols-2">
      <div class="flex items-center justify-center">
        <img
          src="img/cave.png"
          alt="Thought Capture Demo"
          class="h-96 w-full object-cover"
        />
      </div>
      <div transition:fly={{ x: 20, duration: 500 }}>
        <h3 class="mb-4 text-3xl font-bold">Effortless Thought Capture</h3>
        <p class="mb-4">
          Quickly jot down your ideas and watch them grow visually in your mind
          garden. The intuitive interface makes it easy to capture and organize
          your thoughts.
        </p>
        <h3 class="mb-4 text-3xl font-bold">Personalized AI Assistance</h3>
        <p class="mb-4">
          Our AI learns from your unique thought patterns and suggests prompts
          to help your ideas flourish. It's like having a personal gardener for
          your mind.
        </p>
        <h3 class="mb-4 text-3xl font-bold">Private and Secure</h3>
        <p>
          Your mind garden is your private oasis. We use state-of-the-art
          encryption to ensure your thoughts remain confidential and secure.
        </p>
      </div>
    </div>
  </div>
</div>

<!-- How It Works -->
<div class="bg-base-100 py-16" id="how-it-works">
  <div class="container mx-auto px-4 sm:px-6 lg:px-8">
    <div class="mb-12 text-center" transition:fade={{ duration: 500 }}>
      <h2 class="mb-4 text-4xl font-bold">How mind.ai Works</h2>
      <p class="text-xl">
        Our AI-powered journaling process is simple and intuitive.
      </p>
    </div>
    <div class="grid grid-cols-1 gap-8 md:grid-cols-3">
      <div class="card bg-base-200 shadow-xl">
        <figure class="px-10 pt-10">
          <img src="img/waterfall.png" alt="Capture Icon" class="rounded-xl" />
        </figure>
        <div class="card-body items-center text-center">
          <h3 class="card-title">1. Capture</h3>
          <p>Jot down your thoughts, ideas, and experiences in the app.</p>
        </div>
      </div>
      <div class="card bg-base-200 shadow-xl">
        <figure class="px-10 pt-10">
          <img src="img/thoughts.png" alt="Nurture Icon" class="rounded-xl" />
        </figure>
        <div class="card-body items-center text-center">
          <h3 class="card-title">2. Nurture</h3>
          <p>
            Our AI provides personalized prompts and insights to help your ideas
            grow.
          </p>
        </div>
      </div>
      <div class="card bg-base-200 shadow-xl">
        <figure class="px-10 pt-10">
          <img src="img/mountain.png" alt="Flourish Icon" class="rounded-xl" />
        </figure>
        <div class="card-body items-center text-center">
          <h3 class="card-title">3. Flourish</h3>
          <p>Watch your thoughts blossom into a beautiful mind garden.</p>
        </div>
      </div>
    </div>
  </div>
</div>

<!-- Pricing -->
<div class="bg-base-200 py-16" id="pricing">
  <div class="container mx-auto px-4 sm:px-6 lg:px-8">
    <div class="mb-12 text-center" transition:fade={{ duration: 500 }}>
      <h2 class="mb-4 text-4xl font-bold">Simple, Transparent Pricing</h2>
      <p class="text-xl">Choose the plan that best fits your needs.</p>
    </div>
    <div class="grid grid-cols-1 gap-8 md:grid-cols-3">
      <!-- Pricing plans go here -->
    </div>
  </div>
</div>

<!-- Testimonials -->
<div class="bg-base-100 py-16" id="testimonials">
  <div class="container mx-auto px-4 sm:px-6 lg:px-8">
    <h2 class="mb-12 text-center text-4xl font-bold">What Our Users Say</h2>
    <div class="grid grid-cols-1 gap-8 md:grid-cols-2">
      <!-- Testimonials go here -->
    </div>
  </div>
</div>

<!-- Contact -->
<div class="bg-base-200 py-16" id="contact">
  <div class="container mx-auto px-4 sm:px-6 lg:px-8">
    <div class="mb-12 text-center" transition:fade={{ duration: 500 }}>
      <h2 class="mb-4 text-4xl font-bold">Get in Touch</h2>
      <p class="text-xl">
        Have a question or want to learn more? We'd love to hear from you!
      </p>
    </div>
    <div class="flex justify-center">
      <!-- Contact form goes here -->
    </div>
  </div>
</div>

<!-- Footer -->
<footer class="footer footer-center bg-base-100 text-base-content rounded p-10">
  <!-- Footer content goes here -->
</footer>


Path: D:\Modible\Software\pocketbase-sveltekit-starter\sk\src\routes\auditlog\[coll]\[id]\+page.svelte
Contents:
<script lang="ts">
import type { PageData } from "./$types";
import Changes from "./Changes.svelte";

export let data: PageData;
</script>

<table>
  <thead>
    <th>when</th>
    <th>what</th>
    <th>who</th>
  </thead>
  <tbody>
    {#each data.logs as item}
      <tr>
        <td>{item.updated}</td>
        <td>{item.event}</td>
        <td>{item.admin || (Array.isArray(item.expand.user) ? item.expand.user[0]?.name : item.expand.user?.name) || item.user}</td>
      </tr>
      <tr>
        <!--<td colspan="3"><Changes auditlog={item} /></td>-->
      </tr>
    {:else}
      <tr>
        <td colspan="3">No records found.</td>
      </tr>
    {/each}
  </tbody>
</table>


Path: D:\Modible\Software\pocketbase-sveltekit-starter\sk\src\routes\auditlog\[coll]\[id]\+page.ts
Contents:
import { client } from "$lib/pocketbase";
import type { PageLoad } from "./$types";

export const load: PageLoad = async function ({ params: { coll, id } }) {
  const logs = await client.collection("auditlog").getFullList({
    // TODO: access control
    filter: `record="${id}" && collection="${coll}"`,
    expand: "user",
  });
  return {
    logs,
  };
};


Path: D:\Modible\Software\pocketbase-sveltekit-starter\sk\src\routes\auditlog\[coll]\[id]\Changes.svelte
Contents:
<!-- <script lang="ts">
import type { AuditlogResponse } from "$lib/pocketbase/generated-types";

export let auditlog: AuditlogResponse;
$: keys = Object.keys(auditlog.original || {});
</script>

<table>
  <tbody>
    {#each keys as key}
      <tr>
        <th>{key}</th>
        <td><pre>{auditlog.original[key]}</pre></td>
        <td><pre>{auditlog.data[key]}</pre></td>
      </tr>
    {/each}
  </tbody>
</table>

<style>
pre {
  margin: 0;
  padding: 0;
}
</style> -->


Path: D:\Modible\Software\pocketbase-sveltekit-starter\sk\src\routes\create\+page.svelte
Contents:
<script lang="ts">
import { goto } from "$app/navigation";
import { authModel, client, save } from "$lib/pocketbase";
import { marked } from "marked";
import { alertOnFailure } from "$lib/pocketbase/ui";
import {
  promptFormat,
  titlePrompt,
  tagPrompt,
  blogSummaryPrompt,
  imagePrompt,
  introPrompt,
} from "$lib/utils/prompts";
import { onMount } from "svelte";
import {
  generateTextFromChatGPT,
  generateTextFromClaude,
  generateImageFromDreamStudio,
  ensureTagsExist,
} from "$lib/utils/api";

import type {
  PostsResponse,
  PostsRecord,
  TagsResponse,
} from "$lib/pocketbase/generated-types";

import { createEventDispatcher } from "svelte";
import ServiceSelector from "$lib/components/ServiceSelector.svelte";
import InterpretationList from "$lib/components/InterpretationList.svelte";
import LoadingIndicator from "$lib/components/LoadingIndicator.svelte";
import PostContent from "$lib/components/PostContent.svelte";
import TagGroup from "$lib/components/TagGroup.svelte";

const dispatch = createEventDispatcher();
let inputText = "";

interface Service {
  name: string;
  models: string[];
}

const services: Service[] = [
  {
    name: "Anthropic",
    models: [
      "claude-3-haiku-20240307",
      "claude-3-sonnet-20240229",
      "claude-3-opus-20240229",
      "claude-2.1",
      "claude-2.0",
      "claude-instant-1.2",
    ],
  },
  {
    name: "OpenAI",
    models: ["gpt-4-turbo-preview", "gpt-3.5-turbo"],
  },
];
let selectedService = services[0]?.name || "";
let selectedModel = services[0]?.models?.[0] || "";

// Initialize states and reactive variables
let isLoading = {
  content: false,
  title: false,
  tags: false,
  summary: false,
  image: false,
  slug: false,
};
let formSubmitted = false;
let loadingMessage = "";
let currentStep = 0;
let chatGptInts: any[] = [];
let originalPrompt = "";
let base64Image;
let currentTags = "";
let isAuthenticated = false;

let post: PostsRecord = {
  title: "",
  slug: "",
  body: "",
  blogSummary: "",
  featuredImage: "",
  prompt: "",
  userid: "",
  tags: [] as string[],
};

$: chatGptPrompt = "";

const engineId = "stable-diffusion-v1-6";
const apiHost = "https://api.stability.ai";
const apiKey = import.meta.env.VITE_STABILITY_API_KEY;
let responseText = "";

if (!apiKey) {
  console.error("Missing Stability API key.");
  throw new Error("Missing Stability API key.");
}

async function callAPI() {
  try {
    console.log("Calling API...");
    const response = await fetch(`/api/${selectedService.toLowerCase()}`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ text: inputText, model: selectedModel }),
    });
    console.log("Response:", response);

    if (!response.ok) {
      throw new Error("Network response was not ok");
    }

    const data = await response.json();
    console.log("Data:", data);
    responseText = data.result;
  } catch (error) {
    responseText = "Error: " + (error as Error).message;
  }
}

onMount(async () => {
  isAuthenticated = !!$authModel;
  client.autoCancellation(false);
});

async function uploadImageAndSavePost(
  base64Image: string,
  currentTags: string
): Promise<void> {
  try {
    console.log("Uploading image and saving post...");

    const imageBlob = await fetch(`data:image/png;base64,${base64Image}`).then(
      (res) => res.blob()
    );

    if (imageBlob.size > 5242880) {
      throw new Error("Image size exceeds the maximum limit of 5MB.");
    }

    const formData = new FormData();
    formData.append("file", imageBlob, "postImage.png");

    console.log("Uploading image...");

    post.userid = $authModel?.id || "";

    const createdImageRecord = await client
      .collection("images")
      .create(formData);

    console.log("Image uploaded:", createdImageRecord);

    post.featuredImage = createdImageRecord.id;

    console.log("Current Tags:", currentTags);

    const tagsArray = currentTags
      .split(",")
      .map((tag) => tag.trim())
      .filter((tag) => tag);

    console.log("Tags array:", tagsArray);

    const tagIds = await ensureTagsExist(tagsArray);

    console.log("Tag IDs:", tagIds);

    const postToCreate = {
      title: post.title,
      slug: post.slug,
      body: post.body,
      blogSummary: post.blogSummary,
      featuredImage: createdImageRecord.id,
      userid: $authModel?.id || "",
      prompt: post.prompt,
      tags: tagIds,
    };

    console.log("Post to create:", postToCreate);

    const createdPost = await save("posts", postToCreate, true);

    console.log("Post created:", createdPost);

    goto(`${import.meta.env.VITE_APP_SK_URL}/posts/${post.slug}`);
  } catch (error) {
    console.error(`Failed to upload image and save post: ${error}`);
    alertOnFailure(() => `Failed to upload image and save post: ${error}`);
  }
}

$: {
  updateProgressBar(currentStep);
}

function updateProgressBar(step: number) {
  const progressElement = document.querySelector(
    ".progress"
  ) as HTMLProgressElement;
  if (progressElement) {
    progressElement.value = step;
  }
}

async function generateGptInterpretations(promptString: string) {
  if (!$authModel?.id) {
    alert("Please log in to save your post.");
    return;
  }

  currentStep = 1;

  try {
    const interpretationsResponse = (inputText = introPrompt + promptString);

    await callAPI();

    console.log("Interpretations Response:", interpretationsResponse);

    originalPrompt = promptString;

    chatGptInts = parseInterpretations(responseText);
    console.log(chatGptInts);

    formSubmitted = true;
  } catch (error) {
    console.error("Error generating interpretations:", error);
  }
}

function parseInterpretations(completionText: string): string[] {
  if (!completionText) {
    console.error("No completion text found.");
    return [];
  }
  console.log(completionText);

  const interpretations = completionText
    .trim()
    .split("\n")
    .filter((line) => line.trim().length > 0)
    .map((line) => line.trim());

  console.log(interpretations);
  return interpretations;
}

function getCompletions(claudeOutput: string): string {
  const jsonObject = JSON.parse(claudeOutput);

  if (!jsonObject.hasOwnProperty("completion")) {
    throw new Error("Parsed JSON object does not contain a 'completion' key.");
  }

  const completionText = jsonObject.completion;
  if (typeof completionText !== "string") {
    throw new Error("'completion' key does not contain a string value.");
  }

  return completionText;
}

async function generateBlogFromChatGPT(userPrompt: string) {
  if (!$authModel?.id) {
    alert("Please log in to save your post.");
    return;
  }

  currentStep = 0;

  const generateContent = async (
    prompt: string,
    property: keyof typeof post
  ) => {
    inputText = prompt;
    await callAPI();
    post[property] = responseText.replace(/["']/g, "") as never;
    currentStep += 10;
  };

  try {
    post.userid = $authModel?.id || "";

    await generateContent(`${promptFormat}'${userPrompt}'`, "body");
    await generateContent(`${titlePrompt}'${post.body}'`, "title");
    await generateContent(`${tagPrompt}'${post.body}'`, "tags");
    await generateContent(`${blogSummaryPrompt}'${post.body}'`, "blogSummary");

    post.slug = post.title
      .toLowerCase()
      .replace(/\s+/g, "-")
      .replace(/["':]/g, "")
      .substring(0, 50);
    post.prompt = userPrompt;

    inputText = `${imagePrompt}'${post.body}'`;
    await callAPI();
    const base64Image = await generateImageFromDreamStudio(responseText);
    currentStep = 60;

    if (post.tags) {
      const tags = Array.isArray(post.tags) ? post.tags.join(", ") : "";
      await uploadImageAndSavePost(base64Image, tags);
      console.log("Post saved.");
    }
    return {
      title: post.title,
      slug: post.slug,
      body: post.body,
      tags: post.tags,
      blogSummary: post.blogSummary,
      featuredImage: post.featuredImage,
      prompt: userPrompt,
      userid: post.userid,
    };
  } catch (error) {
    alertOnFailure(() => error);
    throw error;
  } finally {
    isLoading.content = false;
    isLoading.title = false;
    isLoading.slug = false;
    isLoading.summary = false;
    isLoading.image = false;
  }
}

function handleInterpretationSelect(
  event: CustomEvent<{ interpretation: string }>
) {
  const interpretation = event.detail.interpretation;
  selectInterpretation(interpretation);
}

function goBack() {
  formSubmitted = false;
}

let isGeneratingBlog = false;

function selectInterpretation(interpretation: string) {
  chatGptPrompt = originalPrompt + " - " + interpretation;
  isGeneratingBlog = true;
  chatGptInts = []; // Clear the chatGptInts array before generating the blog

  isLoading.content = true;
  loadingMessage = "Generating blog...";
  generateBlogFromChatGPT(chatGptPrompt)
    .then(() => {
      isLoading.content = false;
      isGeneratingBlog = false;
    })
    .catch((error) => {
      alertOnFailure(error);
      isLoading.content = false;
      isGeneratingBlog = false;
    });
}
</script>

<div>
  {#if !formSubmitted}
    <main class="container mx-auto my-12 px-4 sm:px-6 lg:px-8">
      <form
        on:submit|preventDefault={() => generateGptInterpretations(chatGptPrompt)}
      >
        <div class="bg-base-200 space-y-6 rounded-lg p-6 shadow">
          <ServiceSelector
            bind:selectedService={selectedService}
            bind:selectedModel={selectedModel}
          />
          <textarea
            class="textarea h-40 w-full resize-none"
            bind:value={chatGptPrompt}
            rows="10"
            placeholder="Enter thoughts here"
          ></textarea>
          <div class="text-right">
            <button type="submit" class="btn btn-primary btn-outline"
              >Generate</button
            >
          </div>
        </div>
      </form>
    </main>
  {:else if chatGptInts.length > 0 && !isGeneratingBlog}
    <main class="container mx-auto my-12 px-4 sm:px-6 lg:px-8">
      <InterpretationList
        interpretations={chatGptInts}
        on:select={handleInterpretationSelect}
        on:back={goBack}
      />
    </main>
  {:else if isGeneratingBlog}
    <LoadingIndicator message="Generating blog..." />
  {:else}
    {#key chatGptPrompt}
      {#if post !== undefined}
        <div
          class="prose prose-sm sm:prose lg:prose-lg xl:prose-xl mx-auto p-4"
        >
          {#if post.featuredImage}
            <figure class="my-4">
              <img
                src={post.featuredImage}
                alt={post.title}
                class="mx-auto rounded-lg shadow-md"
              />
              <figcaption class="mt-2 text-center text-sm">
                {post.title}
              </figcaption>
            </figure>
          {/if}

          <article class="prose lg:prose-lg mx-auto text-justify">
            {#if isLoading.content}
              <LoadingIndicator message="Loading content..." />
            {:else}
              <PostContent content={post.body} />
            {/if}
          </article>

          <div class="mt-8">
            <h2 class="text-2xl">Tags</h2>
            {#if isLoading.tags}
              <LoadingIndicator message="Loading tags..." />
            {:else}
              <p>{post.tags}</p>
            {/if}
          </div>
        </div>
      {/if}
    {/key}
  {/if}
</div>


Path: D:\Modible\Software\pocketbase-sveltekit-starter\sk\src\routes\explore\+page.svelte
Contents:
<script lang="ts">
import { metadata } from "$lib/app/stores";
import { goto } from "$app/navigation";
import { authModel, save } from "$lib/pocketbase";
import { alertOnFailure } from "$lib/pocketbase/ui";
import type { PageData } from "./$types";
import Markdown from "svelte-markdown";

$: test = "";
$metadata.title = "explore";
$metadata.description = "explore ai";
</script>

Coming Soon


Path: D:\Modible\Software\pocketbase-sveltekit-starter\sk\src\routes\hello\+page.svelte
Contents:
<script lang="ts">
import type { PageData } from "./$types";
export let data: PageData;
</script>

<h1>Hello!</h1>
<p>Got the following API response from the backend server</p>
<pre>{JSON.stringify(data)}</pre>


Path: D:\Modible\Software\pocketbase-sveltekit-starter\sk\src\routes\hello\+page.ts
Contents:
import type { PageLoad } from "./$types";

export const load: PageLoad = async function ({ fetch }) {
  const response = await fetch("/api/hello");
  const json = await response.json();
  return {
    ...json,
  };
};


Path: D:\Modible\Software\pocketbase-sveltekit-starter\sk\src\routes\inspire\+page.svelte
Contents:
<script lang="ts">
import { metadata } from "$lib/app/stores";
import { goto } from "$app/navigation";
import { authModel, save, watch } from "$lib/pocketbase";
import { alertOnFailure } from "$lib/pocketbase/ui";
import type { PageData } from "./$types";
import Markdown from "svelte-markdown";
import TagGroup from "$lib/components/TagGroup.svelte";
import { client } from "$lib/pocketbase";
import { onMount, createEventDispatcher } from "svelte";
import type { PostsResponse, Collections } from "$lib/pocketbase/generated-types";
import PostList from "$lib/components/PostList.svelte";

$: test = "";
$metadata.title = "inspire";
$metadata.description = "inspire ai";

const dispatch = createEventDispatcher();
let inputText = "";
let responseText = "";
let posts: PostsResponse[] = [];
let selectedService = "";
let selectedModel = "";

const services = [
  {
    name: "Anthropic",
    models: [
      "claude-3-haiku-20240307",
      "claude-3-sonnet-20240229",
      "claude-3-opus-20240229",
      "claude-2.1",
      "claude-2.0",
      "claude-instant-1.2",
    ],
  },
  {
    name: "OpenAI",
    models: ["gpt-4-turbo-preview", "gpt-3.5-turbo"],
  },
];

async function callAPI() {
  try {
    const response = await fetch(`/api/${selectedService.toLowerCase()}`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ text: inputText, model: selectedModel }),
    });

    if (!response.ok) {
      throw new Error("Network response was not ok");
    }

    const data = await response.json();
    responseText = data.result;
  } catch (error) {
    responseText = "Error: " + (error as Error).message;
  }
}

onMount(async () => {
  // API calls from +page.ts
  try {
    const postsResponse = await client.collection("posts").getList(1, 50, {
      sort: "-updated",
      expand: "featuredImage,tags",
    });
    console.log("postsResponse", postsResponse);

    posts = postsResponse.items.map((post) => {
      const { expand, ...rest } = post;
      return {
        ...rest,
        title: post.title as string,
        slug: post.slug as string,
        body: post.body as string,
        tags: expand.tags ? expand.tags.map((tag: { title: string }) => tag.title) : [],
        collectionName: "posts" as Collections,
      };
    });
  } catch (error) {
    console.error("Error fetching posts:", error);
  }
});
</script>

Coming Soon

<div>
  <div>
  <label class="form-control w-full max-w-xs">
    <select class="select select-bordered" bind:value={selectedService}>
    <option value="">Select an AI</option>
    {#each services as service}
      <option value={service.name}>{service.name}</option>
    {/each}
  </select>
  </label>

  
  {#if selectedService}
  <label class="form-control w-full max-w-xs">
    <select class="select select-bordered" bind:value={selectedService}>
    <option value="">Select an model</option>
    {#each services.find(s => s.name === selectedService)?.models ?? [] as model}
        <option value={model}>{model}</option>
      {/each}
  </select>
  </label>
  {/if}
</div>

  <input type="text" bind:value={inputText} placeholder="Enter text" />
  <button on:click={callAPI} disabled={!selectedService || !selectedModel}
    >Submit</button
  >
</div>

<div>
  <p>Response:</p>
  <div class="response">{responseText}</div>
</div>



Path: D:\Modible\Software\pocketbase-sveltekit-starter\sk\src\routes\posts\+page.svelte
Contents:
<script lang="ts">
  import { metadata } from "$lib/app/stores";
  import Image from "$lib/components/Image.svelte";
  import { authModel, watch } from "$lib/pocketbase";
  import type { PostsResponse } from "$lib/pocketbase/generated-types";
  import { alertOnFailure } from "$lib/pocketbase/ui";
  import { client } from "$lib/pocketbase";
  import Markdown from "svelte-markdown";
  import {onMount} from "svelte";
  import { goto } from "$app/navigation";
  
  async function deleteAllPosts() {
    alertOnFailure(async () => {
      const postsResponse = await client.collection("posts").getList();
      for (const post of postsResponse.items) {
        await client.collection("posts").delete(post.id);
      }
      // Optionally, refresh the posts list or navigate as needed
    });
  }
  
  $metadata.title = "";
  $metadata.description = "AI powered note taking";
  const posts = watch<PostsResponse>("posts", {
    sort: "-updated",
  });
  
  onMount(async () => {
    try {
      const postsResponse = await client.collection("posts").getList(1, 50, {
        sort: "-updated",
        expand: "featuredImage,tags",
      });
  
      posts.update(() => postsResponse.items);
    } catch (error) {
      console.error("Error fetching posts:", error);
    }
  });
  </script>

{#if $posts.items.length > 0}
  {#each $posts.items as post}
    <div
      class="card flex w-full flex-col justify-between bg-base-300 p-4 shadow-xl"
    >
      <div>
        <figure class="relative w-full">
          <img
            src={post.featuredImage}
            alt={post.title}
            class="aspect-[16/9] w-full object-cover sm:aspect-[2/1] lg:aspect-[3/2]"
          />
        </figure>
        <div class="m-4 max-w-xl">
          <div class="prose items-center gap-x-4">
            <time datetime="2020-03-16" class="text-accent">
              {new Date(post.updated).toLocaleDateString()}
            </time>
          </div>
          <div class="group relative mt-3">
            <a
              href={import.meta.env.VITE_APP_SK_URL + "/posts/" + post.slug}
              class="prose-lg line-clamp-2 font-bold text-primary"
            >
              {post.title}
            </a>
            <div
              class="prose-sm mt-3 line-clamp-6 text-justify text-base-content"
            >
              <Markdown source={post.blogSummary || post.body} />
            </div>
          </div>
        </div>
      </div>
      {#each $posts.items as post}
        <!-- ... other post markup ... -->
        <div class="relative mb-4 flex-col gap-x-4 text-center">
          {#await client.collection('postsTags').getList(1, 10, { filter: post.id  }) then postTags}
            {#if postTags.items.length > 0}
              {#each postTags.items as postTag}
                {#await client.collection('tags').getOne(postTag.tags) then tag}
                  <a href="/" class="badge badge-accent badge-outline"
                    >{tag.title}</a
                  >
                {/await}
              {/each}
            {:else}
              <div class="badge badge-accent badge-outline">No tags</div>
            {/if}
          {/await}
        </div>
        <!-- ... other post markup ... -->
      {/each}
      <!-- The rest of your component... -->
    </div>
  {/each}
{/if}

{#if $posts.items.length === 0}
  <div
    class="card flex w-full flex-col justify-between bg-base-300 p-4 shadow-xl"
  >
    <div>
      <div class="m-4 max-w-xl">
        <div class="prose items-center gap-x-4">
          <div class="text-accent">No posts found</div>
        </div>
      </div>
    </div>
  </div>
{/if}


Path: D:\Modible\Software\pocketbase-sveltekit-starter\sk\src\routes\posts\+page.ts
Contents:


Path: D:\Modible\Software\pocketbase-sveltekit-starter\sk\src\routes\posts\[slug]\+page.svelte
Contents:
<script lang="ts">
import type { PostsResponse } from "$lib/pocketbase/generated-types";
import { onMount } from "svelte";
import { page } from "$app/stores";
import { metadata } from "$lib/app/stores";
import Delete from "$lib/components/Delete.svelte";
import { client } from "$lib/pocketbase";
import type { PageData } from "./$types";
import Markdown from "svelte-markdown";
import { base } from "$app/paths";

export let featuredImageUrl: string = "";
export let tags: PostsResponse[] = [];
let post: PostsResponse | undefined;

import TagGroup from "$lib/components/TagGroup.svelte";

onMount(async () => {
  //initialize post, featuredImageUrl, and tags
  // API calls from +page.ts
  const { slug } = $page.params;

  try {
    const response = await client.collection("posts").getList(1, 1, {
      filter: `slug = '${slug}'`,
      expand: "featuredImage,tags",
    });
    const items = response.items;

    if (items.length === 0) {
      throw new Error("Post not found");
    }
    post = items[0] as unknown as PostsResponse;
    console.log("post", post);

    if (post.featuredImage) {
      const image = await client
        .collection("images")
        .getOne(post.featuredImage);
      if (image && image.file) {
        featuredImageUrl = client.getFileUrl(image, image.file);
      }
    }

    if (post.expand?.tags) {
      tags = post.expand.tags;
    }
  } catch (error) {
    console.error("Error fetching post:", error);
  }
});
</script>

{#if post !== undefined}
  {#if $page.url.hash === "#delete"}
    <Delete table="posts" id={post.id} />
  {/if}

  <div class="prose prose-sm sm:prose lg:prose-lg xl:prose-xl mx-auto p-4">
    {#if featuredImageUrl}
      <figure class="my-4">
        <img
          src={featuredImageUrl}
          alt={post.title}
          class="mx-auto rounded-lg shadow-md"
        />
        <figcaption class="mt-2 text-center text-sm">
          {post.title}
        </figcaption>
      </figure>
    {/if}
    <article class="prose lg:prose-lg mx-auto text-justify">
      <Markdown source={post.body} />
    </article>
    <!-- Inside your Svelte component -->
    <div class="mt-8">
      <h2 class="text-2xl">Tags</h2>

      <TagGroup post={post} />
    </div>
    <div class="mt-8 text-center">
      <a href={`${base}/auditlog/posts/${post.id}`} class="btn btn-primary">
        Audit Log
      </a>
    </div>
  </div>
{/if}


Path: D:\Modible\Software\pocketbase-sveltekit-starter\sk\src\routes\posts\[slug]\edit\+page.svelte
Contents:
<script lang="ts">
import { goto } from "$app/navigation";
import { metadata } from "$lib/app/stores";
import { authModel, client, save } from "$lib/pocketbase";
import { alertOnFailure } from "$lib/pocketbase/ui";
import type { PageData } from "./$types";
import Markdown from "svelte-markdown";
import { onMount } from "svelte";
import {
  promptFormat,
  titlePrompt,
  tagPrompt,
  blogSummaryPrompt,
} from "$lib/utils/prompts";
import { page } from "$app/stores";
import Delete from "$lib/components/Delete.svelte";
import {
  generateTextFromChatGPT,
  generateImageFromDalle,
  ensureTagsExist,
} from "$lib/utils/api";

export let data: PageData;

$: ({ post } = data);
$: $metadata.title = post.title;
$: $metadata.description = post.blogSummary || "";
$: featuredImageUrl = data.featuredImageUrl;

let tagString = "";

onMount(async () => {
  if (data && data.post) {
    // Fetch the related tags for the post
    const tagsList: { id: string; title: string }[] = (await client
      .collection("tags")
      .getFullList()) as unknown as { id: string; title: string }[];

    console.log("tagsList", tagsList);

    const tagIds = data.post.tags; // Assuming the tags field in the post collection contains an array of tag IDs

    console.log("tagIds", tagIds);

    const tags = tagIds.map((tagId: string) => {
      console.log("Processing tagId:", tagId);

      const tag = tagsList.find((tag) => {
        console.log("Comparing tagId:", tagId, "with tag.id:", tag.id);
        return tag.id === tagId;
      });

      if (tag) {
        console.log("Found tag:", tag);
        return tag.title;
      } else {
        console.log("Tag not found for tagId:", tagId);
        return "";
      }
    });

    console.log("Mapped tags:", tags);

    const filteredTags = tags.filter((tag) => {
      if (tag === "") {
        console.log("Filtering out empty tag title");
      }
      return tag !== "";
    });

    console.log("Final tags array:", filteredTags);

    tagString = filteredTags.join(", ");
  }
});

async function submit(e: SubmitEvent) {
  e.preventDefault();

  const tagsArray = tagString
    .split(",")
    .map((tag) => tag.trim())
    .filter((tag) => tag.length > 0);

  const updatedPost = {
    ...data.post,
    title: post.title,
    slug: post.slug,
    body: post.body,
    blogSummary: post.blogSummary,
    prompt: post.prompt,
    featuredImage: post.featuredImage,
  };

  const savedPost = await save("posts", updatedPost);

  await updatePostsTagsRelationships(savedPost.id, tagsArray);

  goto(`/posts/${savedPost.slug}`);
}

async function updatePostsTagsRelationships(
  postId: string,
  tagsArray: string[]
) {
  const tagIds = await ensureTagsExist(tagsArray);

  await client.collection("posts").update(postId, {
    tags: tagIds,
  });
}

async function generateFromChatGPT(userPrompt: string) {
  post.prompt = userPrompt;

  const bodyResponse = await generateTextFromChatGPT(
    promptFormat + "This is the user's inspiration: '" + post.prompt + "'"
  );
  post.body = bodyResponse;

  const titleResponse = await generateTextFromChatGPT(
    titlePrompt + "This is the user's article: '" + bodyResponse + "'"
  );
  post.title = titleResponse.replace(/["']/g, "");
  post.slug = titleResponse
    .toLowerCase()
    .replace(/\s+/g, "-")
    .replace(/["':]/g, "")
    .substring(0, 50);

  const tagsResponse = await generateTextFromChatGPT(
    tagPrompt + "This is the blog article: '" + bodyResponse + "'"
  );
  post.tags = [tagsResponse];

  const blogSummaryResponse = await generateTextFromChatGPT(
    blogSummaryPrompt + "This is the blog article: '" + bodyResponse + "'"
  );
  post.blogSummary = blogSummaryResponse;

  const imageResponse = await generateImageFromDalle(
    titleResponse + "  " + tagsResponse
  );

  return {
    title: post.title,
    slug: post.slug,
    body: post.body,
    blogSummary: post.blogSummary,
    userid: post.userid,
    tags: post.tags,
    featuredImage: post.featuredImage,
  };
}
</script>

<main class="container mx-auto my-12 px-4 sm:px-6 lg:px-8">
  <div class="grid gap-8 lg:grid-cols-3">
    <section class="space-y-6 lg:col-span-2">
      <div class="border p-6">
        <h2 class="mb-4 text-lg font-semibold">GPT Prompt</h2>
        <div class="form-control">
          <textarea
            class="textarea h-24 w-full"
            placeholder="Enter your GPT prompt here"
            bind:value={post.prompt}
          ></textarea>
          <button
            class="btn btn-primary mt-4"
            on:click={() => generateFromChatGPT(post.prompt)}>Generate</button
          >
        </div>
      </div>
      <div class="border p-6">
        <h1 class="mb-4 text-xl font-semibold">Edit Journal Entry</h1>
        <form on:submit|preventDefault={submit} class="space-y-4">
          <div class="form-control w-full">
            <label class="label" for="title">
              <span class="label-text">Title</span>
            </label>
            <input
              type="text"
              id="title"
              name="title"
              bind:value={post.title}
              class="input input-bordered w-full"
              placeholder="Your journal title"
            />
          </div>

          <div class="form-control w-full">
            <label class="label" for="slug">
              <span class="label-text">Slug</span>
            </label>
            <input
              type="text"
              id="slug"
              name="slug"
              bind:value={post.slug}
              class="input input-bordered w-full"
              placeholder="your-journal-title"
            />
          </div>

          <div class="form-control w-full">
            <label class="label" for="body">
              <span class="label-text">Body</span>
            </label>
            <article class="prose lg:prose-lg mx-auto text-justify">
              <Markdown source={post.body} />
            </article>
          </div>

          <div class="form-control w-full">
            <label class="label" for="tags">
              <span class="label-text">Tags</span>
            </label>
            <input
              type="text"
              id="tags"
              name="tags"
              bind:value={tagString}
              class="input input-bordered w-full"
              placeholder="Tags, comma separated"
            />
          </div>

          <button type="submit" class="btn btn-primary">Update</button>
        </form>
      </div>
    </section>

    <aside class="space-y-4">
      <div class="card border">
        <figure>
          <img
            src={featuredImageUrl || 'https://via.placeholder.com/256x256.png?text=AI+Blog'}
            alt={post.title}
          />
        </figure>
        <div class="card-body">
          <h3 class="card-title">
            <a href="/" class="text-lg font-bold">{post.title}</a>
          </h3>
          <p>{post.blogSummary || 'No summary available.'}</p>
          <div class="card-actions justify-end">
            {#if tagString}
              {#each tagString.split(',') as tag (tag)}
                <div class="badge badge-outline">{tag.trim()}</div>
              {/each}
            {:else}
              <div class="badge badge-outline">No Tags</div>
            {/if}
          </div>
        </div>
      </div>
    </aside>
  </div>
</main>


Path: D:\Modible\Software\pocketbase-sveltekit-starter\sk\src\routes\posts\[slug]\edit\+page.ts
Contents:
import { client } from "$lib/pocketbase";
import type { PostsRecord } from "$lib/pocketbase/generated-types";
import type { PageLoad } from "./$types";
import { goto } from "$app/navigation";
import { metadata } from "$lib/app/stores";
import { authModel, save } from "$lib/pocketbase";
import type { PageData } from "./$types";

export const load: PageLoad = async function ({ params }) {
  const { slug } = params;

  try {
    const { items } = await client.collection("posts").getList(undefined, undefined, {
      filter: `slug='${slug}'`,
    });

    if (items.length === 0) {
      throw new Error("Post not found");
    }

    const post: {
      userid: any;
      id: string;
      title: string;
      slug: string;
      body: string;
      tags: string[];
      blogSummary: string;
      featuredImage: string | null;
      prompt: string;
    } = items[0] as unknown as {
      userid: any;
      id: string;
      title: string;
      slug: string;
      body: string;
      tags: string[];
      blogSummary: string;
      featuredImage: string | null;
      prompt: string;
    };
    
    let featuredImageUrl = "";

    if (post.featuredImage) {
      const image = await client.collection("images").getOne(post.featuredImage);

      if (image && image.file) {
        featuredImageUrl = client.getFileUrl(image, image.file);
      }
    }

    return { post, featuredImageUrl };
  } catch (error) {
    console.error("Error fetching post:", error);
    throw error;
  }
};

Path: D:\Modible\Software\pocketbase-sveltekit-starter\sk\src\routes\reflect\+page.svelte
Contents:
<script lang="ts">
import { metadata } from "$lib/app/stores";
import { goto } from "$app/navigation";
import { authModel, save } from "$lib/pocketbase";
import { alertOnFailure } from "$lib/pocketbase/ui";
import type { PageData } from "./$types";
import Markdown from "svelte-markdown";

$: test = "";
$metadata.title = "reflect";
$metadata.description = "reflect ai";
</script>

Coming Soon


Path: D:\Modible\Software\pocketbase-sveltekit-starter\sk\src\routes\remember\+page.svelte
Contents:
<script lang="ts">
import { onMount } from "svelte";
import { client, authModel } from "$lib/pocketbase";
import { metadata } from "$lib/app/stores";
import Markdown from "svelte-markdown";
import { goto } from "$app/navigation";
import {
  generateTextFromChatGPT,
  generateImageFromDalle,
} from "$lib/utils/api";
import TagGroup from "$lib/components/TagGroup.svelte";
  import ServiceForm from "$lib/components/ServiceForm.svelte";
import PostList from "$lib/components/PostList.svelte";
import type { PostsResponse } from "$lib/pocketbase/generated-types";

//export const data;

let responseText = '';


$metadata.title = "";
$metadata.description = "AI powered note taking";

async function getFeaturedImageUrl(post: any) {
  if (post.featuredImage) {
    const image = await client.collection("images").getOne(post.featuredImage);
    if (image && image.file) {
      return client.getFileUrl(image, image.file);
    }
  }
  return "https://via.placeholder.com/800x400.png?text=AI+Blog";
}
let posts: string | any[] = [];

//export let post: PostsResponse;

onMount(async () => {
  // API calls from +page.ts
  try {
    const postsResponse = await client.collection("posts").getList(1, 50, {
      sort: "-updated",
      expand: "featuredImage,tags",
    });

    console.log("postsResponse", postsResponse);

    posts = postsResponse.items.map((post) => ({
      ...post,
      tags: post.expand.tags
        ? post.expand.tags.map((tag: { title: any }) => tag.title)
        : [],
    }));

    console.log("postsFinal", posts);
  } catch (error) {
    console.error("Error fetching posts:", error);
  }
});

function handleSubmit(event: { detail: { selectedService: any; selectedModel: any; inputText: any; }; }) {
    const { selectedService, selectedModel, inputText } = event.detail;
    // Call your API with the selected service, model, and input text
    // Update responseText with the result from the API
  }
</script>


<div>
  <div class="mx-auto max-w-7xl px-6 lg:px-8">
    {#if Array.isArray(posts)}
      <PostList {posts} />
    {:else}
      <p>Error: Posts data is not available.</p>
    {/if}
  </div>
</div>


Path: D:\Modible\Software\pocketbase-sveltekit-starter\sk\tests\smoke.test.ts
Contents:
import { test, expect, type Page } from "@playwright/test";
import playwright from "playwright";

const ts = Date.now();
const email = ts + "@test.com";
const password = "0123456789";

async function doLogin(page: Page) {
  await page.locator("summary").click();
  await page.getByPlaceholder("email").fill(email);
  await page.getByPlaceholder("password").fill(password);
  await page.getByRole("button", { name: "Login" }).click();
  const logout = await page.getByRole("button", { name: "Logout" });
  expect(logout).toBeDefined();
  const name = await page.locator("button>samp").innerText();
  expect(name, email);
}

test("posts logged out", async ({ page }) => {
  await page.goto("/posts");
  const heading = await page.getByRole("heading", { name: "Recent Posts" });
  expect(heading).toBeDefined();
  const p = await page.getByText("Please login to create new posts.");
  expect(p).toBeDefined();
});

test("register", async ({ page }) => {
  await page.goto("/posts");
  await page.locator("summary").click();
  await page.getByPlaceholder("email").fill(email);
  await page.getByPlaceholder("password").fill(password);
  await page.getByLabel("Register").check();
  await page.getByPlaceholder("confirm password").fill("0123456789");
  await page.getByRole("button", { name: "Login" }).click();
  const name = await page.locator("button>samp").innerText();
  expect(name, email);
});

test("login", async ({ page }) => {
  await page.goto("/posts");
  await doLogin(page);
  const name = await page.locator("button>samp").innerText();
  expect(name, email);
});

test("posts logged in", async ({ page }) => {
  await page.goto("/posts");
  await doLogin(page);
  const heading = await page.getByRole("heading", { name: "Recent Posts" });
  expect(heading).toBeDefined();
  const link = await page.getByRole("link", { name: "Create New" });
  expect(link).toBeDefined();
});

const title = "post at " + ts;
const slug = "post-" + ts;

test("create post", async ({ page }) => {
  // second browser to test realtime subscriptions
  const b2 = (await (await playwright.chromium.launch()).newPage()) as Page;
  await b2.goto("/posts");
  await doLogin(b2);

  await page.goto("/posts");
  await doLogin(page);
  await page.getByRole("link", { name: "Create New" }).click();
  await page.getByPlaceholder("title").click();
  const ts = Date.now();
  await page.getByPlaceholder("title").fill(title);
  await page.getByPlaceholder("slug").fill(slug);
  await page.getByPlaceholder("body").fill("line 1\nline 2");
  // await page.locator('input[type="file"]').setInputFiles("posts-1.png");
  await page.locator('input[type="file"]').setInputFiles("README.md");
  await page.getByRole("button", { name: "Submit" }).click();
  await expect(page).toHaveURL(/\/posts\/$/);
  await page.getByRole("link", { name: title }).click();
  await expect(page).toHaveURL(/\/posts\/.+\/$/);
  const heading = await page.getByRole("heading", { name: title });
  expect(heading).toBeDefined();
  // check realtime activity in the second browser
  const link = await b2.getByRole("link", { name: title });
  expect(link).toBeDefined();
});

test("delete post", async ({ page }) => {
  await page.goto(`/posts/${slug}/#delete`);
  await doLogin(page);
  await page.getByRole("button", { name: "No - Cancel" }).click();
  await expect(page).toHaveURL(/\/posts\/$/);
  await page.goto(`/posts/${slug}/#delete`);
  await page.getByRole("button", { name: "Yes - Proceed" }).click();
  await expect(page).toHaveURL(/\/posts\/$/);
});




Project Tree View:
├── 
│   ├── .dockerignore
│   ├── click on a bullet point and generat.txt
│   ├── Dockerfile
│   ├── fly.toml
│   ├── LICENSE.md
│   ├── Procfile
│   ├── README.md
│   ├── runit.bat
│   └── textGen.py
├── .vscode
│   └── settings.json
├── pb
│   ├── entrypoint.sh
│   ├── example-hook-script.sh
│   ├── main.go
│   ├── modd.conf
│   ├── README.md
│   ├── auditlog
│   │   └── auditlog.go
│   ├── data
│   │   └── email_templates
│   │       └── post.html
│   ├── hooks
│   │   ├── email.go
│   │   └── hooks.go
│   ├── pb_hooks
│   │   └── main.pb.ts
│   └── pb_public
└── sk
    ├── .prettierignore
    ├── .prettierrc
    ├── playwright.config.ts
    ├── postcss.config.cjs
    ├── README.md
    ├── svelte.config.js
    ├── tailwind.config.cjs
    ├── tsconfig.json
    ├── vite.config.ts
    ├── src
    │   ├── app.d.ts
    │   ├── app.html
    │   ├── app.pcss
    │   ├── app.scss
    │   ├── lib
    │   │   ├── config.ts
    │   │   ├── app
    │   │   │   └── stores.ts
    │   │   ├── components
    │   │   │   ├── Alerts.svelte
    │   │   │   ├── DateShow.svelte
    │   │   │   ├── Delete.svelte
    │   │   │   ├── Dialog.svelte
    │   │   │   ├── FileInput.svelte
    │   │   │   ├── Image.svelte
    │   │   │   ├── InterpretationList.svelte
    │   │   │   ├── LoadingIndicator.svelte
    │   │   │   ├── LoginBadge.svelte
    │   │   │   ├── LoginForm.svelte
    │   │   │   ├── LoginGuard.svelte
    │   │   │   ├── Nav.svelte
    │   │   │   ├── PostCard.svelte
    │   │   │   ├── PostContent.svelte
    │   │   │   ├── PostList.svelte
    │   │   │   ├── ServiceForm.svelte
    │   │   │   ├── ServiceSelector.svelte
    │   │   │   ├── Spinner.svelte
    │   │   │   ├── Tab.svelte
    │   │   │   ├── TabContent.svelte
    │   │   │   ├── TabGroup.svelte
    │   │   │   ├── TagEditor.svelte
    │   │   │   ├── TagGroup.svelte
    │   │   │   └── ThemeSwitch.svelte
    │   │   ├── pocketbase
    │   │   │   ├── generated-types.ts
    │   │   │   ├── ImgModal.svelte
    │   │   │   ├── index.ts
    │   │   │   ├── Paginator.svelte
    │   │   │   ├── pocketbase-types.ts
    │   │   │   └── ui.ts
    │   │   ├── services
    │   │   └── utils
    │   │       ├── api.ts
    │   │       ├── prompts.ts
    │   │       └── themes.ts
    │   └── routes
    │       ├── +layout.svelte
    │       ├── +layout.ts
    │       ├── +page.svelte
    │       ├── auditlog
    │       │   └── [coll]
    │       │       └── [id]
    │       │           ├── +page.svelte
    │       │           ├── +page.ts
    │       │           └── Changes.svelte
    │       ├── create
    │       │   └── +page.svelte
    │       ├── explore
    │       │   └── +page.svelte
    │       ├── hello
    │       │   ├── +page.svelte
    │       │   └── +page.ts
    │       ├── inspire
    │       │   └── +page.svelte
    │       ├── posts
    │       │   ├── +page.svelte
    │       │   ├── +page.ts
    │       │   └── [slug]
    │       │       ├── +page.svelte
    │       │       └── edit
    │       │           ├── +page.svelte
    │       │           └── +page.ts
    │       ├── reflect
    │       │   └── +page.svelte
    │       └── remember
    │           └── +page.svelte
    ├── static
    │   ├── favicon.ico
    │   └── img
    └── tests
        └── smoke.test.ts
